schema {
  query: DotaQuery
  mutation: DotaMutation
  subscription: DotaSubscription
}

type DotaQuery {
  """Find match details by the match id. id is a required input field."""
  match(
    """
    The id of the Dota match to include in this query, excluding all results that do not include this id.
    """
    id: Long!
  ): MatchType

  """Find match details for each match id. ids is a required input field."""
  matches(
    """An array of Dota match ids to include in this query."""
    ids: [Long]!
  ): [MatchType]

  """Find player details by steam account id. id is a required input field."""
  player(
    """
    The steam account id to include in this query, excluding all results that do not have this steam account id.
    """
    steamAccountId: Long!
  ): PlayerType

  """
  Find player details for each steam account id. ids is a required input field.
  """
  players(
    """
    An array of steam account ids to limit the query to only return matches with these steam account ids.
    """
    steamAccountIds: [Long]!
  ): [PlayerType]

  """
  Find player details for each steam account id. ids is a required input field.
  """
  team(
    """
    A team id to include in this query, excluding all results that do not have this team id.
    """
    teamId: Int!
  ): TeamType

  """
  Results in a list of team objects that contain data about them and their players.
  """
  teams(
    """
    A team id to include in this query, excluding all results that do not have this team id.
    """
    teamIds: [Int]!
  ): [TeamType]

  """Find league details by league Id. Id is a required field."""
  league(
    """
    A league id to include in this query, excluding all results that do not have this league id.
    """
    id: Int!
  ): LeagueType

  """Find league details by searching for leagues using a LeagueRequest."""
  leagues(request: LeagueRequestType!): [LeagueType]

  """
  For getting access to one specific Guild which was used at the start of TI10 Compendium.
  """
  guild(
    """
    A guild id to include in this query, excluding all results that do not have this guild id.
    """
    id: Int!
  ): GuildType

  """
  Queries used for Stratz Yogurt - users won't be able to access these calls until they have access to the app.
  """
  yogurt: YogurtQuery

  """Queries used to populate Stratz Plus."""
  plus: PlusQuery

  """Stratz specific queries."""
  stratz: StratzQuery

  """Queries used to gain insights into hero data and statistics."""
  heroStats: HeroStatsQuery

  """Queries used to query constants in Dota."""
  constants: ConstantQuery

  """Queries used to get leaderboard information."""
  leaderboard: LeaderboardQuery

  """Queries used to find live match data."""
  live: LiveQuery

  """Queries used by 3rd party applications."""
  vendor: VendorQuery
}

type MatchType {
  id: Long
  didRadiantWin: Boolean
  durationSeconds: Int
  startDateTime: Long
  endDateTime: Long
  towerStatusRadiant: Int
  towerStatusDire: Int
  barracksStatusRadiant: Short
  barracksStatusDire: Short
  clusterId: Int
  firstBloodTime: Int
  lobbyType: LobbyTypeEnum
  numHumanPlayers: Int
  gameMode: GameModeEnumType
  replaySalt: Long
  isStats: Boolean
  tournamentId: Int
  tournamentRound: Short
  actualRank: Short
  averageRank: Short
  averageImp: Short
  parsedDateTime: Long
  statsDateTime: Long
  leagueId: Int
  league: LeagueType
  radiantTeamId: Int
  radiantTeam: TeamType
  direTeamId: Int
  direTeam: TeamType
  seriesId: Long
  series: SeriesType
  gameVersionId: Short
  regionId: Byte
  sequenceNum: Long
  rank: Int
  bracket: Byte
  analysisOutcome: MatchAnalysisOutcomeType
  predictedOutcomeWeight: Byte
  players(
    """
    The steam account id to include in this query, excluding all results that do not have this steam account id.
    """
    steamAccountId: Long
  ): [MatchPlayerType]

  """This begins at -60 to 0 seconds (Index 0)."""
  radiantNetworthLeads: [Int]

  """This begins at -60 to 0 seconds (Index 0)."""
  radiantExperienceLeads: [Int]

  """This begins at -60 to 0 seconds (Index 0)."""
  radiantKills: [Int]

  """This begins at -60 to 0 seconds (Index 0)."""
  direKills: [Int]

  """This begins at -60 to 0 seconds (Index 0)."""
  pickBans: [MatchStatsPickBanType]
  towerStatus: [MatchStatsTowerReportType]
  laneReport: MatchStatsLaneReportType
  winRates: [Decimal]
  predictedWinRates: [Decimal]
  chatEvents: [MatchStatsChatEventType]
  towerDeaths: [MatchStatsTowerDeathType]
  playbackData: MatchPlaybackDataType
  spectators: [MatchPlayerSpectatorType]
  bottomLaneOutcome: LaneOutcomeEnums
  midLaneOutcome: LaneOutcomeEnums
  topLaneOutcome: LaneOutcomeEnums
}

scalar Long

scalar Short

enum LobbyTypeEnum {
  UNRANKED
  PRACTICE
  TOURNAMENT
  TUTORIAL
  COOP_VS_BOTS
  TEAM_MATCH
  SOLO_QUEUE
  RANKED
  SOLO_MID
  BATTLE_CUP
  EVENT
  DIRE_TIDE
}

enum GameModeEnumType {
  NONE
  ALL_PICK
  CAPTAINS_MODE
  RANDOM_DRAFT
  SINGLE_DRAFT
  ALL_RANDOM
  INTRO
  THE_DIRETIDE
  REVERSE_CAPTAINS_MODE
  THE_GREEVILING
  TUTORIAL
  MID_ONLY
  LEAST_PLAYED
  NEW_PLAYER_POOL
  COMPENDIUM_MATCHMAKING
  CUSTOM
  CAPTAINS_DRAFT
  BALANCED_DRAFT
  ABILITY_DRAFT
  EVENT
  ALL_RANDOM_DEATH_MATCH
  SOLO_MID
  ALL_PICK_RANKED
  TURBO
  MUTATION
}

type LeagueType {
  id: Int
  name: String
  banner: String
  basePrizePool: Int
  stopSalesTime: DateTime
  tier: LeagueTier
  region: LeagueRegion
  private: Boolean
  freeToSpectate: Boolean
  startDateTime: Long
  endDateTime: Long
  tournamentUrl: String
  lastMatchDate: Long
  hasLiveMatches: Boolean
  prizePool: Int
  imageUri: String
  displayName: String
  description: String
  country: String
  venue: String
  isFollowed: Boolean
  nodeGroups: [LeagueNodeGroupType]
  liveMatches: [MatchLiveType]
  matches(
    """
    The request object used to filter matches returned based on input criteria.
    """
    request: LeagueMatchesRequestType!
  ): [MatchType]

  """
  Find match details by steam account id. The return is modified to group the data by the GroupBy parameter.
  """
  matchesGroupBy(
    """
    The request object used to filter matches returned based on input criteria.
    """
    request: PlayerMatchesGroupByRequestType!
  ): [MatchGroupByType]
  series(
    """
    When searching for league matches, an array of the stage type ids the match must be in. Stages: Open Qualifers = 1, Closed Qualifers = 2, Champions Qualifers = 3, Group Stage = 4, Main Event = 5
    """
    leagueStageTypeIds: [LeagueStage]

    """
    A team id to include in this query, excluding all results that do not have this team id.
    """
    teamId: Int

    """
    The amount of data to skip before collecting your query. This is useful for Paging.
    """
    skip: Int

    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int
  ): [SeriesType]
  tables(
    """
    When searching for league matches, an array of the stage type ids the match must be in. Stages: Open Qualifers = 1, Closed Qualifers = 2, Champions Qualifers = 3, Group Stage = 4, Main Event = 5
    """
    leagueStageTypeIds: [LeagueStage]

    """
    To modify the values of Kills, Deaths, Assists, etc.  Accepted inputs are Average (default), Highest, Lowest, Median.
    """
    calculateTypeId: TableCalculateEnum
  ): LeagueTableType
  battlePass: LeagueBattlePassType
  stats(
    """
    When searching for league matches, an array of the stage type ids the match must be in. Stages: Open Qualifers = 1, Closed Qualifers = 2, Champions Qualifers = 3, Group Stage = 4, Main Event = 5
    """
    leagueStageTypeIds: [LeagueStage]
  ): LeagueStatType
  prizePoolPercentages: [LeaguePrizePoolPercentageType]
  standings: [TeamPrizeType]
  streams: [LeagueStreamType]
}

"""
The `DateTime` scalar type represents a date and time. `DateTime` expects timestamps to be formatted in accordance with the [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) standard.
"""
scalar DateTime

enum LeagueTier {
  UNSET
  AMATEUR
  PROFESSIONAL
  MINOR
  MAJOR
  INTERNATIONAL
  DPC_QUALIFIER
  DPC_LEAGUE_QUALIFIER
  DPC_LEAGUE
  DPC_LEAGUE_FINALS
}

enum LeagueRegion {
  UNSET
  NA
  SA
  EUROPE
  CIS
  CHINA
  SEA
}

type LeagueNodeGroupType {
  id: Short
  name: String
  parentNodeGroupId: Short
  advancingNodeGroupId: Short
  advancingTeamCount: Byte
  teamCount: Byte
  defaultNodeType: LeagueNodeDefaultGroupEnum
  nodeGroupType: LeagueNodeGroupTypeEnum
  round: Byte
  maxRounds: Byte
  isTieBreaker: Boolean
  isFinalGroup: Boolean
  isCompleted: Boolean
  phase: Byte
  region: Byte
  startDate: Long
  endDate: Long
  secondaryAdvancingNodeGroupId: Short
  secondaryAdvancingTeamCount: Byte
  tertiaryAdvancingNodeGroupId: Short
  tertiaryAdvancingTeamCount: Byte
  eliminationDPCPoints: Int
  nodes: [LeagueNodeType]
}

scalar Byte

enum LeagueNodeDefaultGroupEnum {
  INVALID
  BEST_OF_ONE
  BEST_OF_THREE
  BEST_OF_FIVE
  BEST_OF_TWO
}

enum LeagueNodeGroupTypeEnum {
  INVALID
  ORGANIZATIONAL
  ROUND_ROBIN
  SWISS
  BRACKET_SINGLE
  BRACKET_DOUBLE_SEED_LOSER
  BRACKET_DOUBLE_ALL_WINNER
  SHOWMATCH
  GSL
}

type LeagueNodeType {
  nodeGroupId: Short
  id: Short
  name: String
  winningNodeId: Short
  losingNodeId: Short
  nodeType: LeagueNodeDefaultGroupEnum
  scheduledTime: Long
  actualTime: Long
  seriesId: Long
  matches: [MatchType]
  teamOneId: Int
  teamOne: TeamType
  teamTwoId: Int
  teamTwo: TeamType
  teamOneWins: Byte
  teamTwoWins: Byte
  hasStarted: Boolean
  isCompleted: Boolean
  streamIds: [Int]
  streams: [LeagueStreamType]
}

type TeamType {
  id: Int!
  name: String
  tag: String
  dateCreated: Long
  isPro: Boolean
  isLocked: Boolean
  countryCode: String
  url: String
  logo: String
  baseLogo: String
  bannerLogo: String
  winCount: Int
  lossCount: Int
  lastMatchDateTime: Long
  countryName: String
  coachSteamAccountId: Long
  coachSteamAccount: SteamAccountType

  """Find match details by leauge id."""
  matches(
    """
    The request object used to filter matches returned based on input criteria.
    """
    request: TeamMatchesRequestType!
  ): [MatchType]

  """Find match details by series id."""
  series(
    """
    The request object used to filter Series returned based on input criteria.
    """
    request: FilterSeriesRequestType!
  ): [SeriesType]

  """A List of all the players for a team."""
  members(
    """
    The amount of data to skip before collecting your query. This is useful for Paging.
    """
    skip: Int

    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int
  ): [SteamAccountTeamMemberType]

  """
  Find match details by team id. The return is modified to group the data by the GroupBy parameter.
  """
  matchesGroupBy(
    """
    The request object used to filter matches returned based on input criteria.
    """
    request: PlayerMatchesGroupByRequestType!
  ): [MatchGroupByType]

  """
  Find match details by team id. The return is modified to group the data by the GroupBy parameter.
  """
  heroPickBan(
    """
    The request object used to filter matches returned based on input criteria.
    """
    request: HeroPickBanRequestType!
  ): [MatchPickBanGroupByType]

  """Find a list of all the leagues that this team has played in."""
  leagues: [LeagueType]
}

type SteamAccountType {
  id: Long
  profileUri: String
  realName: String
  timeCreated: Long
  countryCode: String
  stateCode: String
  cityId: Int
  communityVisibleState: Int
  name: String
  lastLogOff: Long
  avatar: String
  primaryClanId: Long
  isDotaPlusSubscriber: Boolean
  dotaAccountLevel: Short
  rankShift: Short
  isAnonymous: Boolean!
  isStratzPublic: Boolean!
  seasonRank: Byte
  seasonLeaderboardRank: Short
  seasonLeaderboardDivisionId: Byte
  proSteamAccount: ProSteamAccountType
  activity: PlayerActivitySummaryType
  smurfFlag: Byte
  lastMatchDateTime: Long
  lastMatchRegionId: Byte
  battlepass: [SteamAccountBattlePassType]
}

type ProSteamAccountType {
  id: Long
  name: String
  realName: String
  fantasyRole: Byte
  teamId: Int
  sponsor: String
  isLocked: Boolean!
  isPro: Boolean!
  totalEarnings: Int!
  birthday: Long
  romanizedRealName: String
  roles: Byte
  aliases: [String]
  statuses: Byte
  twitterLink: String
  twitchLink: String
  instagramLink: String
  vkLink: String
  youTubeLink: String
  facebookLink: String
  weiboLink: String
  signatureHeroes: [String]
  position: MatchPlayerPositionType
  countries: [String]
  team: TeamType
}

enum MatchPlayerPositionType {
  POSITION_1
  POSITION_2
  POSITION_3
  POSITION_4
  POSITION_5
  UNKNOWN
  FILTERED
  ALL
}

type PlayerActivitySummaryType {
  activity: PlayerBehaviorActivity
}

enum PlayerBehaviorActivity {
  NONE
  VERY_LOW
  LOW
  MEDIUM
  HIGH
  VERY_HIGH
  INTENSE
}

type SteamAccountBattlePassType {
  steamAccountId: Long
  eventId: Byte
  level: Int
}

input TeamMatchesRequestType {
  """
  The steam account id to include in this query, excluding all results that do not have this steam account id.
  """
  steamAccountId: Byte

  """An array of Dota match ids to include in this query."""
  matchIds: [Long]

  """
  A league id to include in this query, excluding all results that do not have this league id.
  """
  leagueId: Int

  """
  A series id to include in this query, excluding all results that do not have this series id.
  """
  seriesId: Long

  """
  Whether STRATZ has yet parsed the data of the match or not, represented in a boolean.
  """
  isParsed: Boolean

  """
  The start DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  startDateTime: Long

  """
  The end DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  endDateTime: Long

  """
  An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
  """
  gameModeIds: [Byte]

  """
  An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types.
  """
  lobbyTypeIds: [Byte]

  """
  An array of game version ids to include in this query, excluding all results that do not include one of these game versions.
  """
  gameVersionIds: [Int]

  """
  An array of region ids to include in this query, excluding all results that do not include one of these regions.
  """
  regionIds: [Int]

  """
  An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-80 with 0 being unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars.
  """
  rankIds: [Int]

  """
  STRATZ applys an formula to determine if a game is considered 'real'. We attempt to detect AFKers, leavers, feeders, etc. 'IsStats' will return matches that do not include any of these poor quality matches.
  """
  isStats: Boolean

  """
  An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
  """
  heroIds: [Short]

  """
  An array of lane ids (enum MatchLaneType) to include in this query, excluding all results that do not include one of these lanes. Roaming = 0, SafeLane = 1, Midlane = 2, Offlane = 3, Jungle = 4
  """
  laneIds: [Int]

  """
  An array of role ids (enum MatchPlayerRoleType) to include in this query, excluding all results that do not include one of these roles. Core = 0, Light Support = 1, Hard Support = 2
  """
  roleIds: [Int]

  """
  An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes.
  """
  positionIds: [MatchPlayerPositionType]

  """
  An array of award ids to include in this query, excluding all results that do not include one of these awards. The player award types include MVP (1), Top Core (2), and Top Support (3).
  """
  awardIds: [Int]

  """Include all matches that are party games, excluding all others."""
  isParty: Boolean

  """
  STRATZ gives 3 players in each game an award for playing well. MVP, Top Core, Top Support (enum MatchPlayerAwardType). If you include a query of 'steamAccountId' then it will require that player to have gotten at least 1 of these awards for each match result.
  """
  hasAward: Boolean

  """
  An array of steam account ids found on your team to include in this query, excluding all results that do not include one of these steam accounts found on your team.
  """
  withFriendSteamAccountIds: [Long]

  """
  An array of hero ids found on your team to include in this query, excluding all results that do not include one of these heroes found on your team.
  """
  withFriendHeroIds: [Int]

  """
  Determines if you want a single player returned, only the player by SteamAccountId, or if you want all 10 players in the match.
  """
  playerList: FindMatchPlayerList

  """The amount of matches to have returned in your query. Max : """
  take: Int!

  """
  The amount of matches to skip before collecting your query. Hint: Paging
  """
  skip: Int!
}

enum FindMatchPlayerList {
  ALL
  SINGLE
  WITH
  AGAINST
}

type SeriesType {
  id: Long!
  type: Series
  teamOneId: Int
  teamTwoId: Int
  leagueId: Int
  teamOneWinCount: Short!
  teamTwoWinCount: Short!
  winningTeamId: Int
  lastMatchDateTime: Long
  matches: [MatchType]
  teamOne: TeamType
  teamTwo: TeamType
  league: LeagueType
  node: LeagueNodeType
}

enum Series {
  BEST_OF_ONE
  BEST_OF_THREE
  BEST_OF_FIVE
  BEST_OF_TWO
}

input FilterSeriesRequestType {
  """
  The amount to have returned in your query. The maximum of this is always dynamic. Limit : 20
  """
  take: Int

  """
  The amount of data to skip before collecting your query. This is useful for Paging.
  """
  skip: Int
}

type SteamAccountTeamMemberType {
  steamAccountId: Long!
  steamAccount: SteamAccountType
  player: PlayerType
  teamId: Int!
  firstMatchId: Long
  firstMatchDateTime: Long
  lastMatchId: Long
  lastMatchDateTime: Long
  team: TeamType
}

type PlayerType {
  steamAccountId: Long
  identity: CaptainJackIdentityPublicProfileType
  steamAccount: SteamAccountType
  matchCount: Int
  winCount: Int
  imp: Int
  firstMatchDate: Long
  lastMatchDate: Long
  lastMatchRegionId: Byte
  ranks(
    """An array of season in which Dota creates each year for ranks."""
    seasonRankIds: [Byte]
  ): [SteamAccountSeasonRankType]
  leaderboardRanks(
    """
    The amount of data to skip before collecting your query. This is useful for Paging.
    """
    skip: Int

    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int
  ): [SteamAccountSeasonLeaderBoardRankType]
  badges: [PlayerBadgeType]
  names(
    """
    The amount of data to skip before collecting your query. This is useful for Paging.
    """
    skip: Int

    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int
  ): [SteamAccountNameType]
  behaviorScore: Short
  team: SteamAccountTeamMemberType
  guildMember: GuildMemberType
  activity: PlayerActivitySummaryType
  isFollowed: Boolean
  simpleSummary: PlayerCardHoverType
  performance: PlayerPerformanceType
  heroPerformance(
    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short!

    """
    The request object used to filter matches returned based on input criteria.
    """
    request: PlayerHeroPerformanceMatchesRequestType!
  ): PlayerPerformanceType

  """
  Returns a list of all heroes played by the steam account id and contains data about the average performance.
  """
  heroesPerformance(
    """
    The request object used to filter matches returned based on input criteria.
    """
    request: PlayerHeroPerformanceMatchesRequestType

    """
    Normally, you use Take inside the request object.  But due to Take being used to determine how many matches to look at, this take will limit the amount of rows being returned from the results.
    """
    take: Int

    """
    Normally, you use Skip inside the request object.  But due to Skip being used to determine how many matches to look at, this skip will skip the amount of rows being returned from the results.
    """
    skip: Int
  ): [PlayerHeroesPerformanceType]

  """
  Find match details by steam account id. steamAccountId is a required input field.
  """
  matches(
    """
    The request object used to filter matches returned based on input criteria.
    """
    request: PlayerMatchesRequestType!
  ): [MatchType]

  """
  Find match details by steam account id. The return is modified to group the data by the GroupBy parameter.
  """
  matchesGroupBy(
    """
    The request object used to filter matches returned based on input criteria.
    """
    request: PlayerMatchesGroupByRequestType!
  ): [MatchGroupByType]

  """
  Gets the players of Dota which have DotaPlus and have a high level hero.
  """
  dotaPlus: [HeroDotaPlusLeaderboardRankType]

  """
  A list of the current Streak and the Longest Streak for each Hero by a Player.
  """
  heroStreaks(
    """
    The request object used to filter matches returned based on input criteria.
    """
    request: PlayerMatchesRequestType
  ): [PlayerHeroPerformanceLongestStreakType]

  """A list of the high achivement skills by a Player."""
  feats(take: Int, skip: Int): [FeatType]
}

type CaptainJackIdentityPublicProfileType {
  captainJackIdentityId: Guid
  name: String
  twitter: String
  facebook: String
  twitch: String
  youTube: String
  isAdmin: Boolean
}

scalar Guid

type SteamAccountSeasonRankType {
  seasonRankId: Byte
  asOfDateTime: Long
  isCore: Boolean
  rank: Byte
}

type SteamAccountSeasonLeaderBoardRankType {
  steamAccountId: Long
  seasonRankId: Byte
  actionsPerMinute: [Int]
  seasonLeaderBoardDivisionId: Byte
  rank: Short
}

type PlayerBadgeType {
  badgeId: Byte
  slot: Byte
  createdDateTime: Long
}

type SteamAccountNameType {
  name: String
  lastSeenDateTime: Long
}

type GuildMemberType {
  guildId: Int
  steamAccountId: Int
  joinDateTime: Long
  guild: GuildType
  steamAccount: SteamAccountType
  matchCount: Int
  winCount: Int
  imp: Int
}

type GuildType {
  id: Int
  motd: String
  name: String
  tag: String
  createdDateTime: Long
  language: Byte
  flags: Int
  logo: String
  region: Byte
  description: String
  requiredRank: Byte
  primaryColor: Byte
  secondaryColor: Byte
  pattern: Byte
  points: Int
  pastWeeklyRank: Int
  pastWeeklyPercentile: Byte
  currentPercentile: Byte
  lastUpdateDateTime: Long
  members: [GuildMemberType]
  matches(
    """
    The amount of data to skip before collecting your query. This is useful for Paging.
    """
    skip: Int

    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int
  ): [MatchType]
  memberCount: Byte
  totalBattlePassLevels: Int
  rank: Byte
}

type PlayerCardHoverType {
  steamAccount: SteamAccountType
  lastUpdateDateTime: Long
  matchCount: Int
  coreCount: Int
  supportCount: Int
  imp: Int
  heroes: [PlayerCardHoverHeroType]
  activity: Byte
}

type PlayerCardHoverHeroType {
  heroId: Int!
  winCount: Int!
  lossCount: Int!
}

type PlayerPerformanceType {
  heroId: [Short]
  matchCount: Int!
  winCount: Int!
  streak: Int!
  maxStreak: Int!
  imp: Int
  rank: Int
  mmrTier: Int!
  mmrBracket: Int!
  awardMatchCount: Int!
  mvpCount: Int!
  topCoreCount: Int!
  topSupportCount: Int!
  kills: Int
  killsAverage: Decimal
  deaths: Int
  deathsAverage: Decimal
  assists: Int
  assistsAverage: Decimal
  cs: Int
  csAverage: Decimal
  gpm: Int
  gpmAverage: Decimal
  xpm: Int
  xpmAverage: Decimal
  composition: PlayerPerformanceCompositionType
  position: [PlayerPerformancePositionType]

  """
  Contains an array of 6 items which are listed as index 0 - 1st Pick, Index 1 - Pick 2nd, 3rd, Index 2 - Pick 4th, 5th, Index 3 - Pick 6th, Pick 7th, Index 4 - Pick 8th, 9ths, Index 5 - Pick 10th
  """
  pickOrder: [Int]
}

scalar Decimal

type PlayerPerformanceCompositionType {
  allies: [PlayerPerformanceCompositionHeroType]
  foes: [PlayerPerformanceCompositionHeroType]
}

type PlayerPerformanceCompositionHeroType {
  heroId: Short
  matchCount: Int!
  winCount: Int!
}

type PlayerPerformancePositionType {
  roleType: Byte
  roleMatchCount: Int!
  roleWinCount: Int!
  lanes: [PlayerPerformancePositionObjectType]
}

type PlayerPerformancePositionObjectType {
  laneType: Byte
  laneMatchCount: Int!
  laneWinCount: Int!
}

input PlayerHeroPerformanceMatchesRequestType {
  matchGroupOrderBy: FilterMatchGroupOrderByEnum

  """If the return should be ordered by Ascending or Desending order."""
  orderBy: FindMatchPlayerOrderBy

  """An array of Dota match ids to include in this query."""
  matchIds: [Long]

  """
  A league id to include in this query, excluding all results that do not have this league id.
  """
  leagueId: Int

  """
  A series id to include in this query, excluding all results that do not have this series id.
  """
  seriesId: Long

  """
  A team id to include in this query, excluding all results that do not have this team id.
  """
  teamId: Int

  """
  Whether STRATZ has yet parsed the data of the match or not, represented in a boolean.
  """
  isParsed: Boolean

  """Whether the match is a league match or not."""
  isLeague: Boolean

  """Whether the match has a team assigned or not."""
  isTeam: Boolean

  """
  Requests matches where the match is at least this many minutes. Default is null and there is no minimum.
  """
  minDuration: Int

  """
  Requests matches where the match is no longer than this many minutes.  Default is null and there is no maximum.
  """
  maxDuration: Int

  """
  The start DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  startDateTime: Long

  """
  The end DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  endDateTime: Long

  """
  An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
  """
  gameModeIds: [Byte]

  """
  An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types.
  """
  lobbyTypeIds: [Byte]

  """
  An array of game version ids to include in this query, excluding all results that do not include one of these game versions.
  """
  gameVersionIds: [Int]

  """
  Requests matches where the match is at least than this input.  See GameVersion API call for a list of patch ids. Default is null and there is no minimum.
  """
  minGameVersionId: Int

  """
  Requests matches where the match is lower than this input.  See GameVersion API call for a list of patch ids. Default is null and there is no maximum.
  """
  maxGameVersionId: Int

  """
  An array of region ids to include in this query, excluding all results that do not include one of these regions.
  """
  regionIds: [Int]

  """
  An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-80 with 0 being unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars.
  """
  rankIds: [Int]

  """
  STRATZ applys an formula to determine if a game is considered 'real'. We attempt to detect AFKers, leavers, feeders, etc. 'IsStats' will return matches that do not include any of these poor quality matches.
  """
  isStats: Boolean

  """
  An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
  """
  heroIds: [Short]

  """
  An array of lane ids (enum MatchLaneType) to include in this query, excluding all results that do not include one of these lanes. Roaming = 0, SafeLane = 1, Midlane = 2, Offlane = 3, Jungle = 4
  """
  laneIds: [Int]

  """
  An array of role ids (enum MatchPlayerRoleType) to include in this query, excluding all results that do not include one of these roles. Core = 0, Light Support = 1, Hard Support = 2
  """
  roleIds: [Int]

  """
  An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes.
  """
  positionIds: [MatchPlayerPositionType]

  """
  An array of award ids to include in this query, excluding all results that do not include one of these awards. The player award types include MVP (1), Top Core (2), and Top Support (3).
  """
  awardIds: [Int]

  """Include all matches that are party games, excluding all others."""
  isParty: Boolean

  """Whether the specified player was on Radiant or not."""
  isRadiant: Boolean

  """
  Matches where the user is in a party with this many friends. Automatically applys IsParty = true. This is an array input.
  """
  partyCounts: [Int]

  """
  STRATZ gives 3 players in each game an award for playing well. MVP, Top Core, Top Support (enum MatchPlayerAwardType). If you include a query of 'steamAccountId' then it will require that player to have gotten at least 1 of these awards for each match result.
  """
  hasAward: Boolean

  """
  An array of steam account ids found on your team to include in this query, excluding all results that do not include one of these steam accounts found on your team.
  """
  withFriendSteamAccountIds: [Long]

  """
  An array of hero ids found on your team to include in this query, excluding all results that do not include one of these heroes found on your team.
  """
  withFriendHeroIds: [Int]
}

enum FilterMatchGroupOrderByEnum {
  MATCH_COUNT
  WIN_COUNT
}

enum FindMatchPlayerOrderBy {
  DESC
  ASC
}

type PlayerHeroesPerformanceType {
  heroId: Short!
  hero: HeroType
  winCount: Int!
  kDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  duration: Int!
  imp: Int
  best: Float
  matchCount: Int!
  goldPerMinute: Int!
  experiencePerMinute: Int!
  positionScore: [PlayerHeroesPerformanceScoreType]
  lastPlayedDateTime: Long
}

type HeroType {
  id: Short
  name: String
  displayName: String
  shortName: String
  aliases: [String]
  gameVersionId: Short
  abilities: [HeroAbilityType]
  roles: [HeroRoleType]
  language: HeroLanguageType
  talents: [HeroTalentType]
  stats: HeroStatType
}

type HeroAbilityType {
  slot: Byte!
  gameVersionId: Short!
  abilityId: Short!
  ability: AbilityType
}

type AbilityType {
  id: Short
  name: String
  uri: String
  language: AbilityLanguageType
  stat: AbilityStatType
  attributes: [AbilityAttributeType]
  isTalent: Boolean
}

type AbilityLanguageType {
  displayName: String
  description: [String]
  attributes: [String]
  lore: String
  aghanimDescription: String
  shardDescription: String
  notes: [String]
}

type AbilityStatType {
  abilityId: Short
  type: Int
  behavior: Long
  unitTargetType: Long
  unitTargetTeam: Int
  unitTargetFlags: Long
  unitDamageType: Int
  spellImmunity: Int
  modifierSupportValue: Float
  modifierSupportBonus: Short
  isOnCastbar: Boolean
  isOnLearnbar: Boolean
  fightRecapLevel: Short
  isGrantedByScepter: Boolean
  hasScepterUpgrade: Boolean
  maxLevel: Byte
  levelsBetweenUpgrades: Byte
  requiredLevel: Byte
  hotKeyOverride: String
  displayAdditionalHeroes: Boolean
  castRange: [Int]
  castRangeBuffer: [Int]
  castPoint: [Float]
  channelTime: [Float]
  cooldown: [Float]
  damage: [Float]
  manaCost: [Float]
  isUltimate: Boolean
  duration: String
  charges: String
  chargeRestoreTime: String
  isGrantedByShard: Boolean
  dispellable: AbilityDispellEnum
  linkedAbilityId: Short
}

enum AbilityDispellEnum {
  NONE
  NO
  YES
  YES_STRONG
}

type AbilityAttributeType {
  name: String
  value: String
  linkedSpecialBonusAbilityId: Short
  requiresScepter: Boolean
}

type HeroRoleType {
  roleId: HeroRoleEnum
  level: Short
}

enum HeroRoleEnum {
  CARRY
  ESCAPE
  NUKER
  INITIATOR
  DURABLE
  DISABLER
  JUNGLER
  SUPPORT
  PUSHER
}

type HeroLanguageType {
  displayName: String
  lore: String
  hype: String
}

type HeroTalentType {
  abilityId: Short
  slot: Byte
}

type HeroStatType {
  enabled: Boolean
  heroUnlockOrder: Float
  team: Boolean
  cMEnabled: Boolean
  newPlayerEnabled: Boolean
  attackType: String
  startingArmor: Float
  startingMagicArmor: Float
  startingDamageMin: Float
  startingDamageMax: Float
  attackRate: Float
  attackAnimationPoint: Float
  attackAcquisitionRange: Float
  attackRange: Float
  primaryAttribute: String
  strengthBase: Float
  strengthGain: Float
  intelligenceBase: Float
  intelligenceGain: Float
  agilityBase: Float
  agilityGain: Float
  hpRegen: Float
  mpRegen: Float
  moveSpeed: Float
  moveTurnRate: Float
  hpBarOffset: Float
  visionDaytimeRange: Float
  visionNighttimeRange: Float
  complexity: Byte
}

type PlayerHeroesPerformanceScoreType {
  id: MatchPlayerPositionType
  score: Float!
  matchCount: Int!
  winCount: Int!
  imp: Int
}

input PlayerMatchesRequestType {
  """An array of Dota match ids to include in this query."""
  matchIds: [Long]

  """
  A league id to include in this query, excluding all results that do not have this league id.
  """
  leagueId: Int

  """
  A series id to include in this query, excluding all results that do not have this series id.
  """
  seriesId: Long

  """
  A team id to include in this query, excluding all results that do not have this team id.
  """
  teamId: Int

  """
  When requesting matches with a primary SteamAccountId, this will ensure that player is on specific team Id being sent in.
  """
  teamIdSteamAccount: Int

  """
  Whether STRATZ has yet parsed the data of the match or not, represented in a boolean.
  """
  isParsed: Boolean

  """
  The start DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  startDateTime: Long

  """
  The end DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  endDateTime: Long

  """
  An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
  """
  gameModeIds: [Byte]

  """
  An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types.
  """
  lobbyTypeIds: [Byte]

  """
  An array of game version ids to include in this query, excluding all results that do not include one of these game versions.
  """
  gameVersionIds: [Int]

  """
  An array of region ids to include in this query, excluding all results that do not include one of these regions.
  """
  regionIds: [Int]

  """
  An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-80 with 0 being unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars.
  """
  rankIds: [Int]

  """
  An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
  """
  bracketIds: [Int]

  """
  STRATZ applys an formula to determine if a game is considered 'real'. We attempt to detect AFKers, leavers, feeders, etc. 'IsStats' will return matches that do not include any of these poor quality matches.
  """
  isStats: Boolean

  """
  An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
  """
  heroIds: [Short]

  """
  An array of lane ids (enum MatchLaneType) to include in this query, excluding all results that do not include one of these lanes. Roaming = 0, SafeLane = 1, Midlane = 2, Offlane = 3, Jungle = 4
  """
  laneIds: [Int]

  """
  An array of role ids (enum MatchPlayerRoleType) to include in this query, excluding all results that do not include one of these roles. Core = 0, Light Support = 1, Hard Support = 2
  """
  roleIds: [Int]

  """
  An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes.
  """
  positionIds: [MatchPlayerPositionType]

  """
  An array of award ids to include in this query, excluding all results that do not include one of these awards. The player award types include MVP (1), Top Core (2), and Top Support (3).
  """
  awardIds: [Int]

  """Include all matches that are party games, excluding all others."""
  isParty: Boolean

  """
  STRATZ gives 3 players in each game an award for playing well. MVP, Top Core, Top Support (enum MatchPlayerAwardType). If you include a query of 'steamAccountId' then it will require that player to have gotten at least 1 of these awards for each match result.
  """
  hasAward: Boolean

  """
  An array of steam account ids found on your team to include in this query, excluding all results that do not include one of these steam accounts found on your team.
  """
  withFriendSteamAccountIds: [Long]

  """
  A steam account id found on the enemy team to include in this query, excluding all results that do not include this steam account id found on the enemy team.
  """
  withEnemySteamAccountIds: [Long]

  """
  An array of hero ids found on your team to include in this query, excluding all results that do not include one of these heroes found on your team.
  """
  withFriendHeroIds: [Int]

  """
  Requests matches where the match is at least than this input.  See GameVersion API call for a list of patch ids. Default is null and there is no minimum.
  """
  minGameVersionId: Int

  """
  Requests matches where the match is lower than this input.  See GameVersion API call for a list of patch ids. Default is null and there is no maximum.
  """
  maxGameVersionId: Int

  """
  Determines if you want a single player returned, only the player by SteamAccountId, or if you want all 10 players in the match.
  """
  playerList: FindMatchPlayerList

  """The amount of matches to have returned in your query. Max : """
  take: Int

  """
  The amount of matches to skip before collecting your query. Hint: Paging
  """
  skip: Int

  """Only return matches after this match id. Can be used instead of Skip."""
  after: Long

  """Only return matches before this match id. Can be used instead of Skip."""
  before: Long

  """In what order the returned data will come in."""
  orderBy: FindMatchPlayerOrderBy
}

union MatchGroupByType = MatchGroupByHeroType | MatchGroupByFactionType | MatchGroupByKillsType | MatchGroupByDeathsType | MatchGroupByAssistsType | MatchGroupByIsLeaverType | MatchGroupByLevelType | MatchGroupByIsPartyType | MatchGroupByIsRandomType | MatchGroupByLaneType | MatchGroupByRoleType | MatchGroupByIsIntentionalFeedingType | MatchGroupByAwardType | MatchGroupByRoamLaneType | MatchGroupByIsVictoryType | MatchGroupByDurationMinutesType | MatchGroupByClusterType | MatchGroupByRegionType | MatchGroupByLobbyTypeType | MatchGroupByIsLeagueType | MatchGroupByIsSeriesType | MatchGroupByGameModeType | MatchGroupByIsStatsType | MatchGroupByGameVersionType | MatchGroupByTeamType | MatchGroupByHeroPerformanceType | MatchGroupBySteamAccountIdType | MatchGroupBySteamAccountIdHeroIdType | MatchGroupBySteamAccountIdWithTeamType | MatchGroupBySteamAccountIdHeroIdWithTeamType | MatchGroupBySteamAccountIdAgainstTeamType | MatchGroupBySteamAccountIdHeroIdAgainstTeamType | MatchGroupByLeagueIdType | MatchGroupByPositionType | MatchGroupByDateDayType | MatchGroupByTotalKillsType | MatchGroupByGoldPerMinuteType

type MatchGroupByHeroType {
  heroId: Long
  hero(
    """
    The game version id to include in this query, excluding all results that do not have this game version.
    """
    gameVersionId: Short!
  ): HeroType
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupByFactionType {
  isRadiant: Boolean
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupByKillsType {
  killCount: Long
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupByDeathsType {
  deathCount: Long
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupByAssistsType {
  assistCount: Long
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupByIsLeaverType {
  isLeaver: Boolean
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupByLevelType {
  level: Long
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupByIsPartyType {
  isParty: Boolean
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupByIsRandomType {
  isRandom: Boolean
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupByLaneType {
  lane: MatchLaneType
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

enum MatchLaneType {
  ROAMING
  SAFE_LANE
  MID_LANE
  OFF_LANE
  JUNGLE
  UNKNOWN
}

type MatchGroupByRoleType {
  role: MatchPlayerRoleType
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

enum MatchPlayerRoleType {
  CORE
  LIGHT_SUPPORT
  HARD_SUPPORT
  UNKNOWN
}

type MatchGroupByIsIntentionalFeedingType {
  isIntentionalFeeding: Boolean
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupByAwardType {
  award: MatchPlayerAward
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

enum MatchPlayerAward {
  NONE
  MVP
  TOP_CORE
  TOP_SUPPORT
}

type MatchGroupByRoamLaneType {
  roamLane: MatchPlayerAward
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupByIsVictoryType {
  isVictory: Boolean
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupByDurationMinutesType {
  durationMinutes: Long
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupByClusterType {
  cluster: Long
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupByRegionType {
  region: Long
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupByLobbyTypeType {
  lobbyType: Long
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupByIsLeagueType {
  isLeague: Boolean
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupByIsSeriesType {
  isSeries: Boolean
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupByGameModeType {
  gameMode: Long
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupByIsStatsType {
  isStats: Boolean
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupByGameVersionType {
  gameVersion: Long
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupByTeamType {
  teamId: Long
  team: TeamType
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupByHeroPerformanceType {
  heroPeroformance: Long
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupBySteamAccountIdType {
  steamAccountId: Long
  steamAccount: SteamAccountType
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupBySteamAccountIdHeroIdType {
  steamAccountId: Long
  steamAccount: SteamAccountType
  heroId: Short
  hero(
    """
    The game version id to include in this query, excluding all results that do not have this game version.
    """
    gameVersionId: Short!
  ): HeroType
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupBySteamAccountIdWithTeamType {
  steamAccountId: Long
  steamAccount: SteamAccountType
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupBySteamAccountIdHeroIdWithTeamType {
  steamAccountId: Long
  steamAccount: SteamAccountType
  heroId: Short
  hero(
    """
    The game version id to include in this query, excluding all results that do not have this game version.
    """
    gameVersionId: Short!
  ): HeroType
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupBySteamAccountIdAgainstTeamType {
  steamAccountId: Long
  steamAccount: SteamAccountType
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupBySteamAccountIdHeroIdAgainstTeamType {
  steamAccountId: Long
  steamAccount: SteamAccountType
  heroId: Short
  hero(
    """
    The game version id to include in this query, excluding all results that do not have this game version.
    """
    gameVersionId: Short!
  ): HeroType
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupByLeagueIdType {
  leagueId: Long
  league: LeagueType
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupByPositionType {
  position: MatchPlayerPositionType
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupByDateDayType {
  dateDay: Long
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupByTotalKillsType {
  totalKills: Long
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

type MatchGroupByGoldPerMinuteType {
  goldPerMinute: Long
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

input PlayerMatchesGroupByRequestType {
  """
  Only used when doing matchesGroupBy endpoint.  This is how the data will be grouped and makes your return Id field.
  """
  groupBy: FindMatchPlayerGroupBy!

  """An array of Dota match ids to include in this query."""
  matchIds: [Long]

  """
  A league id to include in this query, excluding all results that do not have this league id.
  """
  leagueId: Int

  """
  A series id to include in this query, excluding all results that do not have this series id.
  """
  seriesId: Long

  """
  A team id to include in this query, excluding all results that do not have this team id.
  """
  teamId: Int

  """
  Whether STRATZ has yet parsed the data of the match or not, represented in a boolean.
  """
  isParsed: Boolean

  """
  The start DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  startDateTime: Long

  """
  The end DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  endDateTime: Long

  """
  An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
  """
  gameModeIds: [Byte]

  """
  An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types.
  """
  lobbyTypeIds: [Byte]

  """
  An array of game version ids to include in this query, excluding all results that do not include one of these game versions.
  """
  gameVersionIds: [Int]

  """
  An array of region ids to include in this query, excluding all results that do not include one of these regions.
  """
  regionIds: [Int]

  """
  An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-80 with 0 being unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars.
  """
  rankIds: [Int]

  """
  An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
  """
  bracketIds: [Int]

  """
  STRATZ applys an formula to determine if a game is considered 'real'. We attempt to detect AFKers, leavers, feeders, etc. 'IsStats' will return matches that do not include any of these poor quality matches.
  """
  isStats: Boolean

  """
  An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
  """
  heroIds: [Short]

  """
  An array of lane ids (enum MatchLaneType) to include in this query, excluding all results that do not include one of these lanes. Roaming = 0, SafeLane = 1, Midlane = 2, Offlane = 3, Jungle = 4
  """
  laneIds: [Int]

  """
  An array of role ids (enum MatchPlayerRoleType) to include in this query, excluding all results that do not include one of these roles. Core = 0, Light Support = 1, Hard Support = 2
  """
  roleIds: [Int]

  """
  An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes.
  """
  positionIds: [MatchPlayerPositionType]

  """
  An array of award ids to include in this query, excluding all results that do not include one of these awards. The player award types include MVP (1), Top Core (2), and Top Support (3).
  """
  awardIds: [Int]

  """Include all matches that are party games, excluding all others."""
  isParty: Boolean

  """
  STRATZ gives 3 players in each game an award for playing well. MVP, Top Core, Top Support (enum MatchPlayerAwardType). If you include a query of 'steamAccountId' then it will require that player to have gotten at least 1 of these awards for each match result.
  """
  hasAward: Boolean

  """
  An array of steam account ids found on your team to include in this query, excluding all results that do not include one of these steam accounts found on your team.
  """
  withFriendSteamAccountIds: [Long]

  """
  An array of hero ids found on your team to include in this query, excluding all results that do not include one of these heroes found on your team.
  """
  withFriendHeroIds: [Int]

  """
  Requests matches where the match is at least than this input.  See GameVersion API call for a list of patch ids. Default is null and there is no minimum.
  """
  minGameVersionId: Int

  """
  Requests matches where the match is lower than this input.  See GameVersion API call for a list of patch ids. Default is null and there is no maximum.
  """
  maxGameVersionId: Int

  """
  Determines if you want a single player returned, only the player by SteamAccountId, or if you want all 10 players in the match.
  """
  playerList: FindMatchPlayerList!

  """The amount of matches to have returned in your query. Max : """
  take: Int!

  """
  The amount of matches to skip before collecting your query. Hint: Paging
  """
  skip: Int
}

enum FindMatchPlayerGroupBy {
  HERO
  FACTION
  KILLS
  DEATHS
  ASSISTS
  IS_LEAVER
  LEVEL
  IS_PARTY
  IS_RANDOM
  LANE
  ROLE
  IS_INTENTIONAL_FEEDING
  AWARD
  ROAM_LANE
  IS_VICTORY
  DURATION_MINUTES
  CLUSTER
  REGION
  LOBBY_TYPE
  IS_LEAGUE
  IS_SERIES
  GAME_MODE
  IS_STATS
  GAME_VERSION
  TEAM
  HERO_PERFORMANCE
  STEAM_ACCOUNT_ID
  STEAM_ACCOUNT_ID_HERO_ID
  STEAM_ACCOUNT_ID_WITH_TEAM
  STEAM_ACCOUNT_ID_HERO_ID_WITH_TEAM
  STEAM_ACCOUNT_ID_AGAINST_TEAM
  STEAM_ACCOUNT_ID_HERO_ID_AGAINST_TEAM
  LEAGUE_ID
  POSITION
  DATE_DAY
  TOTAL_KILLS
  GOLD_PER_MINUTE
}

type HeroDotaPlusLeaderboardRankType {
  heroId: Short
  steamAccountId: Long
  level: Byte
  totalActions: Long
  createdDateTime: Long
  steamAccount: SteamAccountType
}

type PlayerHeroPerformanceLongestStreakType {
  heroId: Short
  longestStreak: Int
  currentStreak: Int
}

type FeatType {
  type: Feat
  value: Int
  heroId: Int
  hero: HeroType
  matchId: Long
  match: MatchType
}

enum Feat {
  RAMPAGE
  WIN_STREAK
  HIGH_IMP
  DOTA_ACCOUNT_LEVEL
}

type MatchPickBanGroupByType {
  heroId: Short
  matchCount: Int
  pickCount: Int
  banCount: Int
}

input HeroPickBanRequestType {
  """An array of Dota match ids to include in this query."""
  matchIds: [Long]

  """
  A league id to include in this query, excluding all results that do not have this league id.
  """
  leagueId: Int

  """
  A series id to include in this query, excluding all results that do not have this series id.
  """
  seriesId: Long

  """
  A team id to include in this query, excluding all results that do not have this team id.
  """
  teamId: Int

  """
  Whether STRATZ has yet parsed the data of the match or not, represented in a boolean.
  """
  isParsed: Boolean

  """
  The start DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  startDateTime: Long

  """
  The end DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  endDateTime: Long

  """
  An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
  """
  gameModeIds: [Byte]

  """
  An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types.
  """
  lobbyTypeIds: [Byte]

  """
  An array of game version ids to include in this query, excluding all results that do not include one of these game versions.
  """
  gameVersionIds: [Int]

  """
  An array of region ids to include in this query, excluding all results that do not include one of these regions.
  """
  regionIds: [Int]

  """
  An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-80 with 0 being unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars.
  """
  rankIds: [Int]

  """
  An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
  """
  bracketIds: [Int]

  """
  STRATZ applys an formula to determine if a game is considered 'real'. We attempt to detect AFKers, leavers, feeders, etc. 'IsStats' will return matches that do not include any of these poor quality matches.
  """
  isStats: Boolean

  """
  An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
  """
  heroIds: [Short]

  """
  An array of lane ids (enum MatchLaneType) to include in this query, excluding all results that do not include one of these lanes. Roaming = 0, SafeLane = 1, Midlane = 2, Offlane = 3, Jungle = 4
  """
  laneIds: [Int]

  """
  An array of role ids (enum MatchPlayerRoleType) to include in this query, excluding all results that do not include one of these roles. Core = 0, Light Support = 1, Hard Support = 2
  """
  roleIds: [Int]

  """
  An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes.
  """
  positionIds: [MatchPlayerPositionType]

  """
  An array of award ids to include in this query, excluding all results that do not include one of these awards. The player award types include MVP (1), Top Core (2), and Top Support (3).
  """
  awardIds: [Int]

  """Include all matches that are party games, excluding all others."""
  isParty: Boolean

  """
  STRATZ gives 3 players in each game an award for playing well. MVP, Top Core, Top Support (enum MatchPlayerAwardType). If you include a query of 'steamAccountId' then it will require that player to have gotten at least 1 of these awards for each match result.
  """
  hasAward: Boolean

  """
  Requests matches where the match is at least than this input.  See GameVersion API call for a list of patch ids. Default is null and there is no minimum.
  """
  minGameVersionId: Int

  """
  Requests matches where the match is lower than this input.  See GameVersion API call for a list of patch ids. Default is null and there is no maximum.
  """
  maxGameVersionId: Int

  """Only return matches after this match id. Can be used instead of Skip."""
  after: Long

  """Only return matches before this match id. Can be used instead of Skip."""
  before: Long
}

type LeagueStreamType {
  id: Int
  languageId: Language
  name: String
  broadcastProvider: Byte
  streamUrl: String
  vodUrl: String
}

enum Language {
  ENGLISH
  BRAZILIAN
  BULGARIAN
  CZECH
  DANISH
  DUTCH
  FINNISH
  FRENCH
  GERMAN
  GREEK
  HUNGARIAN
  ITALIAN
  JAPANESE
  KOREAN
  KOREANA
  NORWEGIAN
  POLISH
  PORTUGUESE
  ROMANIAN
  RUSSIAN
  S_CHINESE
  SPANISH
  SWEDISH
  T_CHINESE
  THAI
  TURKISH
  UKRAINIAN
}

type MatchLiveType {
  matchId: Long
  radiantScore: Byte
  direScore: Byte
  leagueId: Int
  league: LeagueType
  delay: Short
  spectators: Int
  averageRank: Int
  buildingState: Long
  radiantLead: Int
  lobbyId: Long
  lobbyType: LobbyTypeEnum
  serverSteamId: Long
  gameTime: Int
  completed: Boolean
  isUpdating: Boolean
  isParsing: Boolean
  radiantTeamId: Int
  direTeamId: Int
  radiantTeam: TeamType
  direTeam: TeamType
  parseBeginGameTime: Int
  numHumanPlayers: Byte
  gameMode: GameModeEnumType
  playbackData: MatchLivePlaybackDataType
  gameState: MatchLiveGameState
  gameMinute: Short
  players: [MatchLivePlayerType]
  createdDateTime: Long
  modifiedDateTime: Long
  insight: MatchLiveInsightType
  winRateValues: [Float]
  durationValues: [Float]
  liveWinRateValues: [MatchLiveWinRateDetailType]
}

type MatchLivePlaybackDataType {
  roshanEvents: [MatchLiveRoshanDetailType]
  buildingEvents: [MatchLiveBuildingDetailType]
  pickBans: [MatchLivePickBanType]
  radiantScore: [MatchLiveTeamScoreDetailType]
  direScore: [MatchLiveTeamScoreDetailType]
}

type MatchLiveRoshanDetailType {
  time: Int
  isAlive: Boolean
  respawnTimer: Int
}

type MatchLiveBuildingDetailType {
  time: Int!
  indexId: Int
  type: BuildingType
  isAlive: Boolean!
  positionX: Int
  positionY: Int
  isRadiant: Boolean
  npcId: Int
}

enum BuildingType {
  FORT
  TOWER
  BARRACKS
  HEALER
  OUTPOST
}

type MatchLivePickBanType {
  isPick: Boolean!
  heroId: Short
  order: Int
  bannedHeroId: Short
  isRadiant: Boolean
  baseWinRate: Float
  adjustedWinRate: Float
  letter: PlusLetterType
  positionValues: [Float]
  winRateValues: [Float]
  durationValues: [Float]
  position: MatchPlayerPositionType
}

enum PlusLetterType {
  F
  D
  C
  B
  A
  S
}

type MatchLiveTeamScoreDetailType {
  time: Int
  score: Short
}

enum MatchLiveGameState {
  INIT
  WAIT_FOR_PLAYERS_TO_LOAD
  HERO_SELECTION
  STRATEGY_TIME
  PRE_GAME
  GAME_IN_PROGRESS
  POST_GAME
  DISCONNECT
  TEAM_SHOWCASE
  CUSTOM_GAME_SETUP
  WAIT_FOR_MAP_TO_LOAD
  LAST
}

type MatchLivePlayerType {
  matchId: Long
  heroId: Short
  hero: HeroType
  name: String
  playerSlot: Byte
  steamAccountId: Long
  steamAccount: SteamAccountType
  isRadiant: Boolean
  numKills: Byte
  numDeaths: Byte
  numAssists: Byte
  leaverStatus: Byte
  numLastHits: UShort
  numDenies: UShort
  goldPerMinute: UShort
  experiencePerMinute: UShort
  level: Byte
  gold: Int
  goldSpent: Int
  heroDamage: Int
  towerDamage: Int
  itemId0: Short
  itemId1: Short
  itemId2: Short
  itemId3: Short
  itemId4: Short
  itemId5: Short
  backpackId0: Short
  backpackId1: Short
  backpackId2: Short
  playbackData: MatchPlayerLivePlaybackDataType
  networth: Int
  respawnTimer: Short
  ultimateCooldown: Short
  ultimateState: Short
  impPerMinute: [MatchLivePlayerImpDetailType]
  gameVersionId: Short
  baseWinRateValue: Float
  position: MatchPlayerPositionType
}

scalar UShort

type MatchPlayerLivePlaybackDataType {
  positionEvents: [MatchLivePlayerPositionDetailType]
  goldEvents: [MatchLivePlayerGoldDetailType]
  levelEvents: [MatchLivePlayerLevelDetailType]
  killEvents: [MatchLivePlayerKillDetailType]
  deathEvents: [MatchLivePlayerDeathDetailType]
  assistEvents: [MatchLivePlayerAssistDetailType]
  csEvents: [MatchLivePlayerLastHitDetailType]
  denyEvents: [MatchLivePlayerDenyDetailType]
  experienceEvents: [MatchLivePlayerExperienceDetailType]
  inventoryEvents: [MatchLivePlayerInventoryDetailType]
}

type MatchLivePlayerPositionDetailType {
  time: Int!
  x: Int!
  y: Int!
}

type MatchLivePlayerGoldDetailType {
  time: Int!
  gold: Int!
  networth: Int!
  networthDifference: Int!
  goldPerMinute: Int!
}

type MatchLivePlayerLevelDetailType {
  time: Int!
  level: Int!
}

type MatchLivePlayerKillDetailType {
  time: Int!
  positionX: Int!
  positionY: Int!
}

type MatchLivePlayerDeathDetailType {
  time: Int!
  positionX: Int!
  positionY: Int!
}

type MatchLivePlayerAssistDetailType {
  time: Int!
  positionX: Int!
  positionY: Int!
}

type MatchLivePlayerLastHitDetailType {
  time: Int!
  positionX: Int!
  positionY: Int!
}

type MatchLivePlayerDenyDetailType {
  time: Int!
  positionX: Int!
  positionY: Int!
}

type MatchLivePlayerExperienceDetailType {
  time: Int!
  expPerMinute: Int!
}

type MatchLivePlayerInventoryDetailType {
  time: Int!
  itemId0: Short
  itemId1: Short
  itemId2: Short
  itemId3: Short
  itemId4: Short
  itemId5: Short
  backpackId0: Short
  backpackId1: Short
  backpackId2: Short
}

type MatchLivePlayerImpDetailType {
  time: Int!
  imp: Short!
}

type MatchLiveInsightType {
  teamOneVsWinCount: Int!
  teamTwoVsWinCount: Int!
  teamOneLeagueWinCount: Int!
  teamOneLeagueMatchCount: Int!
  teamTwoLeagueWinCount: Int!
  teamTwoLeagueMatchCount: Int!
  lastSeries: [SeriesType]
}

type MatchLiveWinRateDetailType {
  time: Int!
  winRate: Float!
}

input LeagueMatchesRequestType {
  """
  The steam account id to include in this query, excluding all results that do not have this steam account id.
  """
  steamAccountId: Long

  """An array of Dota match ids to include in this query."""
  matchIds: [Long]

  """
  A series id to include in this query, excluding all results that do not have this series id.
  """
  seriesId: Long

  """
  A team id to include in this query, excluding all results that do not have this team id.
  """
  teamId: Int

  """
  Whether STRATZ has yet parsed the data of the match or not, represented in a boolean.
  """
  isParsed: Boolean

  """
  The start DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  startDateTime: Long

  """
  The end DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  endDateTime: Long

  """
  An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
  """
  gameModeIds: [Byte]

  """
  An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types.
  """
  lobbyTypeIds: [Byte]

  """
  An array of game version ids to include in this query, excluding all results that do not include one of these game versions.
  """
  gameVersionIds: [Int]

  """
  An array of region ids to include in this query, excluding all results that do not include one of these regions.
  """
  regionIds: [Int]

  """
  An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-80 with 0 being unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars.
  """
  rankIds: [Int]

  """
  STRATZ applys an formula to determine if a game is considered 'real'. We attempt to detect AFKers, leavers, feeders, etc. 'IsStats' will return matches that do not include any of these poor quality matches.
  """
  isStats: Boolean

  """
  An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
  """
  heroIds: [Short]

  """
  An array of lane ids (enum MatchLaneType) to include in this query, excluding all results that do not include one of these lanes. Roaming = 0, SafeLane = 1, Midlane = 2, Offlane = 3, Jungle = 4
  """
  laneIds: [Int]

  """
  An array of role ids (enum MatchPlayerRoleType) to include in this query, excluding all results that do not include one of these roles. Core = 0, Light Support = 1, Hard Support = 2
  """
  roleIds: [Int]

  """
  An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes.
  """
  positionIds: [MatchPlayerPositionType]

  """
  An array of award ids to include in this query, excluding all results that do not include one of these awards. The player award types include MVP (1), Top Core (2), and Top Support (3).
  """
  awardIds: [Int]

  """Include all matches that are party games, excluding all others."""
  isParty: Boolean

  """
  STRATZ gives 3 players in each game an award for playing well. MVP, Top Core, Top Support (enum MatchPlayerAwardType). If you include a query of 'steamAccountId' then it will require that player to have gotten at least 1 of these awards for each match result.
  """
  hasAward: Boolean

  """
  An array of stage type ids to include in this query, excluding all results that do not include one of these stage types.
  """
  leagueStageTypeIds: [LeagueStage]

  """
  An array of steam account ids found on your team to include in this query, excluding all results that do not include one of these steam accounts found on your team.
  """
  withFriendSteamAccountIds: [Long]

  """
  An array of hero ids found on your team to include in this query, excluding all results that do not include one of these heroes found on your team.
  """
  withFriendHeroIds: [Int]

  """The amount of matches to have returned in your query. Max : """
  take: Int!

  """
  The amount of matches to skip before collecting your query. Hint: Paging
  """
  skip: Int!
}

enum LeagueStage {
  OPEN_QUALIFERS
  CLOSED_QUALIFERS
  CHAMPIONS_QUALIFERS
  GROUP_STAGE
  MAIN_EVENT
}

type LeagueTableType {
  leagueId: Int!
  tableTeams: [LeagueTableTeamType]
  tableHeroes: [LeagueTableHeroType]
  tablePlayers: [LeagueTablePlayerType]
}

type LeagueTableTeamType {
  teamId: Int
  team: TeamType
  members: [LeagueRegisteredPlayerType]
  overview: LeagueTableTeamOverviewType
  stats: LeagueTableTeamStatsType
  heroes: [LeagueTableTeamHeroesObjectType]
  lanes: [LeagueTableTeamLanesObjectType]
}

type LeagueRegisteredPlayerType {
  leagueId: Int
  league: LeagueType
  teamId: Int
  radiantTeam: TeamType
  steamAccountId: Long
  steamAccount: SteamAccountType
}

type LeagueTableTeamOverviewType {
  points: Float
  earnings: Float
  seriesCount: Int!
  seriesWins: Int!
  seriesDraws: Int!
  matchCount: Int!
  matchWins: Int!
  tmp: Float
}

type LeagueTableTeamStatsType {
  kills: Float!
  deaths: Float!
  assists: Float!
  cs: Float!
  gpm: Float!
  xpm: Float!
  heal: Float!
  heroDamage: Float!
  towerDamage: Float!
  duration: Float!
}

type LeagueTableTeamHeroesObjectType {
  heroId: Int!
  matchCount: Int!
  matchWins: Int!
  imp: Decimal
  banCount: Int
}

type LeagueTableTeamLanesObjectType {
  id: Byte
  matchCount: Int!
  matchWins: Int!
}

type LeagueTableHeroType {
  heroId: Short
  overview: LeagueTableHeroOverviewType
  stats: LeagueTableHeroStatsType
  heroes: [LeagueTableHeroStatsType]
  lanes: [LeagueTableHeroLanesObjectType]
}

type LeagueTableHeroOverviewType {
  matchCount: Int!
  matchWins: Int!
  pickPhaseOne: Int!
  pickPhaseTwo: Int!
  pickPhaseThree: Int!
  banCount: Int!
  banPhaseOne: Int!
  banPhaseTwo: Int!
  banPhaseThree: Int!
}

type LeagueTableHeroStatsType {
  kills: Float!
  deaths: Float!
  assists: Float!
  cs: Float!
  gpm: Float!
  xpm: Float!
  heal: Float!
  heroDamage: Float!
  towerDamage: Float!
  killContribution: Float!
}

type LeagueTableHeroLanesObjectType {
  id: Byte
  matchCount: Int!
  matchWins: Int!
}

type LeagueTablePlayerType {
  steamAccountId: Long
  steamAccount: SteamAccountType
  overview: LeagueTablePlayerOverviewType
  stats: LeagueTablePlayerStatsType
  heroes: [LeagueTablePlayerHeroesObjectType]
  lanes: [LeagueTablePlayerLanesObjectType]
}

type LeagueTablePlayerOverviewType {
  points: Float
  earnings: Float
  seriesCount: Int!
  seriesWins: Int!
  matchCount: Int!
  matchWins: Int!
  imp: Int!
}

type LeagueTablePlayerStatsType {
  kills: Float!
  deaths: Float!
  assists: Float!
  cs: Float!
  gpm: Float!
  xpm: Float!
  heal: Float!
  heroDamage: Float!
  towerDamage: Float!
  killContribution: Float!
}

type LeagueTablePlayerHeroesObjectType {
  heroId: Int!
  matchCount: Int!
  matchWins: Int!
  imp: Int!
}

type LeagueTablePlayerLanesObjectType {
  id: Byte
  matchCount: Int!
  matchWins: Int!
}

enum TableCalculateEnum {
  AVERAGE
  MEDIAN
  HIGHEST
  LOWEST
}

type LeagueBattlePassType {
  count: Int
  average: Int
}

type LeagueStatType {
  matchCount: Int
  radiantWinMatchCount: Int
  averageMatchDurationSeconds: Int
}

type LeaguePrizePoolPercentageType {
  leagueId: Int
  index: Byte
  percentage: Int
}

type TeamPrizeType {
  leagueId: Int
  league: LeagueType
  teamId: Int
  team: TeamType
  standing: Int
  prizeAmount: Float
}

enum MatchAnalysisOutcomeType {
  NONE
  STOMPED
  COMEBACK
  CLOSE_GAME
}

type MatchPlayerType {
  matchId: Long
  match: MatchType
  playerSlot: Byte
  steamAccountId: Long
  steamAccount: SteamAccountType
  isRadiant: Boolean
  isVictory: Boolean
  heroId: Short
  gameVersionId: Short
  hero: HeroType
  kills: Byte
  deaths: Byte
  assists: Byte
  leaverStatus: LeaverStatusEnum
  numLastHits: Short
  numDenies: Short
  goldPerMinute: Short
  networth: Int
  experiencePerMinute: Short
  level: Byte
  gold: Int
  goldSpent: Int
  heroDamage: Int
  towerDamage: Int
  heroHealing: Int
  partyId: Byte
  isRandom: Boolean
  lane: MatchLaneType
  position: MatchPlayerPositionType
  streakPrediction: Short
  intentionalFeeding: Boolean
  role: MatchPlayerRoleType
  roleBasic: MatchPlayerRoleType
  imp: Short
  award: MatchPlayerAward
  item0Id: Short
  item1Id: Short
  item2Id: Short
  item3Id: Short
  item4Id: Short
  item5Id: Short
  backpack0Id: Short
  backpack1Id: Short
  backpack2Id: Short

  """
  The item id of the dedicated neutral item slot (7.24 and after). From game versions 7.23 to 7.24, this was the BackPack3Id (the 4th backpack slot item id).
  """
  neutral0Id: Short
  behavior: Short
  stats: MatchPlayerStatsType
  playbackData: MatchPlayerPlaybackDataType

  """Detailed output of data per minute for each hero."""
  heroAverage: [HeroPositionTimeDetailType]
  additionalUnit: MatchPlayerAdditionalUnitType

  """
  Gets the players of Dota which have DotaPlus and have a high level hero.
  """
  dotaPlus: HeroDotaPlusLeaderboardRankType
  abilities(
    """
    The game version id to include in this query, excluding all results that do not have this game version.
    """
    gameVerionId: Int
  ): [PlayerAbilityType]
  invisibleSeconds: Int
  dotaPlusHeroXp: Int
}

enum LeaverStatusEnum {
  NONE
  DISCONNECTED
  DISCONNECTED_TOO_LONG
  ABANDONED
  AFK
  NEVER_CONNECTED
  NEVER_CONNECTED_TOO_LONG
  FAILED_TO_READY_UP
  DECLINED_READY_UP
}

type MatchPlayerStatsType {
  matchId: Long
  steamAccountId: Long
  gameVersionId: Short
  level: [Int]
  killEvents: [MatchPlayerStatsKillEventType]
  deathEvents: [MatchPlayerStatsDeathEventType]
  assistEvents: [MatchPlayerStatsAssistEventType]
  lastHitsPerMinute: [Int]
  goldPerMinute: [Int]
  experiencePerMinute: [Int]
  healPerMinute: [Int]
  heroDamagePerMinute: [Int]
  towerDamagePerMinute: [Int]
  towerDamageReport: [MatchPlayerStatsTowerDamageReportType]
  courierKills: [MatchPlayerStatsCourierKillEventType]
  wards: [MatchPlayerStatsWardEventType]
  itemPurchases: [MatchPlayerItemPurchaseEventType]
  itemUsed: [MatchPlayerStatsItemUsedEventType]
  allTalks: [MatchPlayerStatsAllTalkEventType]
  chatWheels: [MatchPlayerStatsChatWheelEventType]
  actionsPerMinute: [Int]
  actionReport: MatchPlayerStatsActionReportType
  locationReport: [MatchPlayerStatsLocationReportType]
  farmDistributionReport: MatchPlayerStatsFarmDistributionReportType
  runes: [MatchPlayerStatsRuneEventType]
  abilityCastReport: [MatchPlayerStatsAbilityCastReportType]
  heroDamageReport: MatchPlayerStatsHeroDamageReportType
  inventoryReport: [MatchPlayerInventoryType]
  networthPerMinute: [Int]
  campStack: [Int]
  matchPlayerBuffEvent: [MatchPlayerStatsBuffEventType]
  deniesPerMinute: [Int]
  impPerMinute: [Int]
  tripsFountainPerMinute: [Int]
  spiritBearInventoryReport: [MatchPlayerSpiritBearInventoryType]
  heroDamageReceivedPerMinute: [Int]
  wardDestruction: [MatchPlayerWardDestuctionObjectType]
}

type MatchPlayerStatsKillEventType {
  time: Int!
  target: Int
  byAbility: Int
  byItem: Int
  gold: Int
  xp: Int
  positionX: Int
  positionY: Int
  assist: [Int!]
  isSolo: Boolean
  isGank: Boolean
  isInvisible: Boolean
  isSmoke: Boolean
  isTpRecently: Boolean
}

type MatchPlayerStatsDeathEventType {
  time: Int!
  attacker: Short
  target: Int
  byAbility: Int
  byItem: Int
  goldFed: Int
  xpFed: Int
  timeDead: Int
  positionX: Int
  positionY: Int
  goldLost: Int
  assist: [Short!]
  isWardWalkThrough: Boolean
  isAttemptTpOut: Boolean
  isDieBack: Boolean
  isBurst: Boolean
  isEngagedOnDeath: Boolean
  hasHealAvailable: Boolean
  isTracked: Boolean
}

type MatchPlayerStatsAssistEventType {
  time: Int!
  target: Int
  gold: Int
  xp: Int
  positionX: Int
  positionY: Int
}

type MatchPlayerStatsTowerDamageReportType {
  npcId: Int!
  damage: Int!
  damageCreeps: Int!
  damageFromAbility: Int!
}

type MatchPlayerStatsCourierKillEventType {
  time: Int!
  positionX: Int
  positionY: Int
}

type MatchPlayerStatsWardEventType {
  time: Int!
  type: Int!
  positionX: Int
  positionY: Int
}

type MatchPlayerItemPurchaseEventType {
  time: Int!
  itemId: Int!
}

type MatchPlayerStatsItemUsedEventType {
  itemId: Int!
  count: Int
}

type MatchPlayerStatsAllTalkEventType {
  time: Int!
  message: String
  pausedTick: Int!
}

type MatchPlayerStatsChatWheelEventType {
  time: Int!
  chatWheelId: Short
}

type MatchPlayerStatsActionReportType {
  moveToPosition: Int!
  moveToTarget: Int!
  attackPosition: Int!
  attackTarget: Int!
  castPosition: Int!
  castTarget: Int!
  castNoTarget: Int!
  heldPosition: Int!
  glyphCast: Int!
  scanUsed: Int!
  pingUsed: Int!
}

type MatchPlayerStatsLocationReportType {
  positionX: Int!
  positionY: Int!
}

type MatchPlayerStatsFarmDistributionReportType {
  creepType: [MatchPlayerStatsFarmDistributionObjectType]
  creepLocation: [MatchPlayerStatsFarmDistributionObjectType]
  neutralLocation: [MatchPlayerStatsFarmDistributionObjectType]
  ancientLocation: [MatchPlayerStatsFarmDistributionObjectType]
  buildings: [MatchPlayerStatsFarmDistributionObjectType]
  buyBackGold: Int!
  abandonGold: Int!
  bountyGold: MatchPlayerStatsFarmDistributionObjectType
  other: [MatchPlayerStatsFarmDistributionObjectType]
}

type MatchPlayerStatsFarmDistributionObjectType {
  id: Int!
  count: Int!
  gold: Int
  xp: Int
}

type MatchPlayerStatsRuneEventType {
  time: Int!
  rune: RuneEnums
  action: RuneAction
  gold: Int
  positionX: Int
  positionY: Int
}

enum RuneEnums {
  DOUBLE_DAMAGE
  HASTE
  ILLUSION
  INVISIBILITY
  REGEN
  BOUNTY
  ARCANE
  WATER
}

enum RuneAction {
  PICKUP
  BOTTLE
}

type MatchPlayerStatsAbilityCastReportType {
  abilityId: Int!
  count: Int!
  targets: [MatchPlayerStatsAbilityCastObjectType]
}

type MatchPlayerStatsAbilityCastObjectType {
  target: Int!
  count: Int!
  damage: Int!
  duration: Int
}

type MatchPlayerStatsHeroDamageReportType {
  dealtTotal: MatchPlayerHeroDamageTotalReportObjectType
  receivedTotal: MatchPlayerHeroDamageTotalRecievedReportObjectType
  dealtTargets: [MatchPlayerHeroDamageTargetReportObjectType]
  receivedTargets: [MatchPlayerHeroDamageTargetReportObjectType]
  dealtSourceAbility: [MatchPlayerHeroDamageSourceAbilityReportObjectType]
  receivedSourceAbility: [MatchPlayerHeroDamageSourceAbilityReportObjectType]
  dealtSourceItem: [MatchPlayerHeroDamageSourceItemReportObjectType]
  receivedSourceItem: [MatchPlayerHeroDamageSourceItemReportObjectType]
}

type MatchPlayerHeroDamageTotalReportObjectType {
  physicalDamage: Int!
  magicalDamage: Int!
  pureDamage: Int!
  selfHeal: Int!
  allyHeal: Int!
  stunCount: Int!
  stunDuration: Int!
  disableCount: Int!
  disableDuration: Int!
  slowCount: Int!
  slowDuration: Int!
}

type MatchPlayerHeroDamageTotalRecievedReportObjectType {
  physicalDamage: Int!
  magicalDamage: Int!
  pureDamage: Int!
  heal: Int!
  stunCount: Int!
  stunDuration: Int!
  disableCount: Int!
  disableDuration: Int!
  slowCount: Int!
  slowDuration: Int!
}

type MatchPlayerHeroDamageTargetReportObjectType {
  target: Int!
  amount: Int!
}

type MatchPlayerHeroDamageSourceAbilityReportObjectType {
  abilityId: Int!
  count: Int!
  amount: Int!
}

type MatchPlayerHeroDamageSourceItemReportObjectType {
  itemId: Int!
  count: Int!
  amount: Int!
}

type MatchPlayerInventoryType {
  item0: MatchPlayerInventoryObjectType
  item1: MatchPlayerInventoryObjectType
  item2: MatchPlayerInventoryObjectType
  item3: MatchPlayerInventoryObjectType
  item4: MatchPlayerInventoryObjectType
  item5: MatchPlayerInventoryObjectType
  backPack0: MatchPlayerInventoryObjectType
  backPack1: MatchPlayerInventoryObjectType
  backPack2: MatchPlayerInventoryObjectType
  neutral0: MatchPlayerInventoryObjectType
}

type MatchPlayerInventoryObjectType {
  itemId: Int!
  charges: Int
  secondaryCharges: Int
}

type MatchPlayerStatsBuffEventType {
  time: Int!
  abilityId: Int
  itemId: Int
  stackCount: Int
}

type MatchPlayerSpiritBearInventoryType {
  item0Id: Int
  item1Id: Int
  item2Id: Int
  item3Id: Int
  item4Id: Int
  item5Id: Int
  backPack0Id: Int
  backPack1Id: Int
  backPack2Id: Int
  neutral0Id: Int
}

type MatchPlayerWardDestuctionObjectType {
  time: Int!
  gold: Int
  experience: Int
  isWard: Boolean
}

type MatchPlayerPlaybackDataType {
  abilityLearnEvents: [AbilityLearnEventsType]
  abilityUsedEvents: [AbilityUsedEventsType]
  abilityActiveLists: [AbilityActiveListType]
  itemUsedEvents: [ItemUsedEventType]
  playerUpdatePositionEvents: [PlayerUpdatePositionDetailType]
  playerUpdateGoldEvents: [PlayerUpdateGoldDetailType]
  playerUpdateAttributeEvents: [PlayerUpdateAttributeDetailType]
  playerUpdateLevelEvents: [PlayerUpdateLevelDetailType]
  playerUpdateHealthEvents: [PlayerUpdateHealthDetailType]
  playerUpdateBattleEvents: [PlayerUpdateBattleDetailType]
  killEvents: [KillDetailType]
  deathEvents: [DeathDetailType]
  assistEvents: [AssistDetailType]
  csEvents: [LastHitDetailType]
  goldEvents: [GoldDetailType]
  experienceEvents: [ExperienceDetailType]
  healEvents: [HealDetailType]
  heroDamageEvents: [HeroDamageDetailType]
  towerDamageEvents: [TowerDamageDetailType]
  inventoryEvents: [InventoryType]
  purchaseEvents: [ItemPurchaseType]
  buyBackEvents: [BuyBackDetailType]
  streakEvents: [StreakEventType]
  spiritBearInventoryEvents: [SpiritBearInventoryType]
}

type AbilityLearnEventsType {
  time: Int!
  abilityId: Short
  levelObtained: Int!
  level: Int!
  isUltimate: Boolean
  isTalent: Boolean
  isMaxLevel: Boolean
}

type AbilityUsedEventsType {
  time: Int!
  abilityId: Short
  attacker: Short
  target: Short
}

type AbilityActiveListType {
  time: Int!
  ability0: Short
  ability1: Short
  ability2: Short
  ability3: Short
  ability4: Short
  ability5: Short
  ability6: Short
  ability7: Short
}

type ItemUsedEventType {
  time: Int!
  itemId: Short
  attacker: Short
  target: Short
}

type PlayerUpdatePositionDetailType {
  time: Int!
  x: Int!
  y: Int!
}

type PlayerUpdateGoldDetailType {
  time: Int!
  gold: Int!
  unreliableGold: Int!
  networth: Int!
  networthDifference: Int!
}

type PlayerUpdateAttributeDetailType {
  time: Int!
  agi: Int!
  int: Int!
  str: Int!
}

type PlayerUpdateLevelDetailType {
  time: Int!
  level: Int!
}

type PlayerUpdateHealthDetailType {
  time: Int!
  hp: Int!
  maxHp: Int!
  mp: Int!
  maxMp: Int!
}

type PlayerUpdateBattleDetailType {
  time: Int!
  damageMinMax: Int!
  damageBonus: Int!
  hpRegen: Int!
  mpRegen: Int!
}

type KillDetailType {
  time: Int!
  attacker: Short
  isFromIllusion: Boolean
  target: Short
  byAbility: Short
  byItem: Short
  gold: Int
  xp: Int
  positionX: Int
  positionY: Int
  assist: [Int]
  isSolo: Boolean
  isGank: Boolean
  isInvisible: Boolean
  isSmoke: Boolean
  isTpRecently: Boolean
  isRuneEffected: Boolean
}

type DeathDetailType {
  time: Int!
  attacker: Short
  isFromIllusion: Boolean
  target: Short
  byAbility: Short
  byItem: Short
  goldFed: Int
  xpFed: Int
  timeDead: Int
  reliableGold: Int
  unreliableGold: Int
  positionX: Int
  positionY: Int
  goldLost: Int
  assist: [Int]
  isWardWalkThrough: Boolean
  isAttemptTpOut: Boolean
  isDieBack: Boolean
  isBurst: Boolean
  isEngagedOnDeath: Boolean
  hasHealAvailable: Boolean
  isTracked: Boolean
  isFeed: Boolean
}

type AssistDetailType {
  time: Int!
  attacker: Short
  target: Short
  gold: Int
  xp: Int
  subTime: Int
  positionX: Int
  positionY: Int
}

type LastHitDetailType {
  time: Int!
  attacker: Short
  isFromIllusion: Boolean
  npcId: Short
  byAbility: Short
  byItem: Short
  gold: Int
  xp: Int
  positionX: Int
  positionY: Int
  isCreep: Boolean
  isNeutral: Boolean
  isAncient: Boolean
  mapLocation: MapLocationEnums
}

enum MapLocationEnums {
  RADIANT_BASE
  RADIANT_OFF_LANE
  RADIANT_MID_LANE
  RADIANT_SAFE_LANE
  DIRE_BASE
  DIRE_OFF_LANE
  DIRE_MID_LANE
  DIRE_SAFE_LANE
  RIVER
  ROSHAN
  ROAMING
  RADIANT_FOUNTAIN
  DIRE_FOUNTAIN
}

type GoldDetailType {
  time: Int!
  amount: Int!
  reason: GoldReason
  npcId: Int
  isValidForStats: Boolean
}

enum GoldReason {
  OTHER
  DEATH
  BUY_BACK
  ABADONS
  SELLS
  STRUCTURES
  HEROES
  CREEPS
  NEUTRAL
  ROSHAN
  COURIERS
  BOUNTY
  DOOM_DEVOURER
  WARD_DESTRUCTION
}

type ExperienceDetailType {
  time: Int!
  amount: Int!
  reason: XpReason
  positionX: Int
  positionY: Int
}

enum XpReason {
  OTHER
  HEROES
  CREEPS
  ROSHAN
  TOME_OF_KNOWLEDGE
  OUTPOSTS
}

type HealDetailType {
  time: Int!
  attacker: Short
  target: Short
  value: Int
  byAbility: Short
  byItem: Short
}

type HeroDamageDetailType {
  time: Int!
  attacker: Short
  target: Short
  value: Int!
  byAbility: Short
  byItem: Short
  damageType: Damage
  fromNpc: Short
  toNpc: Short
  fromIllusion: Boolean
  toIllusion: Boolean
  isPhysicalAttack: Boolean
  isSourceMainHero: Boolean
  isTargetMainHero: Boolean
}

enum Damage {
  UNKNOWN
  PHYSICAL
  MAGICAL
  PURE
}

type TowerDamageDetailType {
  time: Int!
  attacker: Short
  npcId: Short
  damage: Int!
  byAbility: Short
  byItem: Short
  fromNpc: Short
}

type InventoryType {
  time: Int!
  item0: InventoryObjectType
  item1: InventoryObjectType
  item2: InventoryObjectType
  item3: InventoryObjectType
  item4: InventoryObjectType
  item5: InventoryObjectType
  backPack0: InventoryObjectType
  backPack1: InventoryObjectType
  backPack2: InventoryObjectType
  teleport0: InventoryObjectType
  neutral0: InventoryObjectType
}

type InventoryObjectType {
  itemId: Short
  charges: Int
  secondaryCharges: Int
}

type ItemPurchaseType {
  time: Int!
  itemId: Short
}

type BuyBackDetailType {
  time: Int!
  heroId: Short
  deathTimeRemaining: Int!
  cost: Int!
}

type StreakEventType {
  time: Int!
  heroId: Short
  type: Streak
  value: Int!
}

enum Streak {
  MULTI_KILL
  KILL_STREAK
}

type SpiritBearInventoryType {
  time: Int!
  item0: SpiritBearInventoryObjectType
  item1: SpiritBearInventoryObjectType
  item2: SpiritBearInventoryObjectType
  item3: SpiritBearInventoryObjectType
  item4: SpiritBearInventoryObjectType
  item5: SpiritBearInventoryObjectType
  backPack0: SpiritBearInventoryObjectType
  backPack1: SpiritBearInventoryObjectType
  backPack2: SpiritBearInventoryObjectType
  teleport0: SpiritBearInventoryObjectType
  neutral0: SpiritBearInventoryObjectType
}

type SpiritBearInventoryObjectType {
  itemId: Short
}

type HeroPositionTimeDetailType {
  heroId: Short!
  week: Int!
  time: Int!
  position: MatchPlayerPositionType
  bracketBasicIds: RankBracketBasicEnum
  matchCount: Long
  remainingMatchCount: Long
  winCount: Long
  mvp: Decimal
  topCore: Decimal
  topSupport: Decimal
  courierKills: Decimal
  apm: Decimal
  casts: Decimal
  abilityCasts: Decimal
  kills: Decimal
  deaths: Decimal
  assists: Decimal
  networth: Decimal
  xp: Decimal
  cs: Decimal
  dn: Decimal
  neutrals: Decimal
  heroDamage: Decimal
  towerDamage: Decimal
  physicalDamage: Decimal
  magicalDamage: Decimal
  physicalDamageReceived: Decimal
  magicalDamageReceived: Decimal
  tripleKill: Decimal
  ultraKill: Decimal
  rampage: Decimal
  godLike: Decimal
  disableCount: Decimal
  disableDuration: Decimal
  stunCount: Decimal
  stunDuration: Decimal
  slowCount: Decimal
  slowDuration: Decimal
  healingSelf: Decimal
  healingAllies: Decimal
  invisibleCount: Decimal
  runePower: Decimal
  runeBounty: Decimal
  level: Decimal
  campsStacked: Decimal
  supportGold: Decimal
  purgeModifiers: Decimal
  ancients: Decimal
  teamKills: Decimal
  goldLost: Decimal
  goldFed: Decimal
  buybackCount: Decimal
  weakenCount: Decimal
  weakenDuration: Decimal
  physicalItemDamage: Decimal
  magicalItemDamage: Decimal
  healingItemSelf: Decimal
  healingItemAllies: Decimal
  xpFed: Decimal
  pureDamageReceived: Decimal
  attackDamage: Decimal
  castDamage: Decimal
  damageReceived: Decimal
  damage: Decimal
  pureDamage: Decimal
  kDAAverage: Decimal
  killContributionAverage: Decimal
  stompWon: Decimal
  stompLost: Decimal
  comeBackWon: Decimal
  comeBackLost: Decimal
}

enum RankBracketBasicEnum {
  UNCALIBRATED
  HERALD_GUARDIAN
  CRUSADER_ARCHON
  LEGEND_ANCIENT
  DIVINE_IMMORTAL
  FILTERED
  ALL
}

type MatchPlayerAdditionalUnitType {
  item0Id: Short
  item1Id: Short
  item2Id: Short
  item3Id: Short
  item4Id: Short
  item5Id: Short
  backpack0Id: Short
  backpack1Id: Short
  backpack2Id: Short
  neutral0Id: Short
}

type PlayerAbilityType {
  abilityId: Int!
  time: Int!
  level: Int!
  gameVersionId: Short
  abilityType(
    """
    The game version id to include in this query, excluding all results that do not have this game version.
    """
    gameVerionId: Int

    """
    The language id to include in this query, excluding all results that do not have this language.
    """
    langaugeId: Int
  ): AbilityType
  isTalent: Boolean
}

type MatchStatsPickBanType {
  isPick: Boolean!
  heroId: Short
  team: Int
  order: Int
  bannedHeroId: Short
  isRadiant: Boolean
  playerIndex: Int
  wasBannedSuccessfully: Boolean
  baseWinRate: Byte
  adjustedWinRate: Byte
  letter: Int
}

type MatchStatsTowerReportType {
  towers: [MatchStatsTowerReportObjectType]
  outposts: [MatchStatsOutpostReportObjectType]
}

type MatchStatsTowerReportObjectType {
  npcId: Int
  hp: Int
}

type MatchStatsOutpostReportObjectType {
  npcId: Int
  isControlledByRadiant: Boolean!
  isRadiantSide: Boolean!
}

type MatchStatsLaneReportType {
  radiant: [MatchStatsLaneReportFactionObjectType]
  dire: [MatchStatsLaneReportFactionObjectType]
}

type MatchStatsLaneReportFactionObjectType {
  midLane: MatchStatsLaneReportFactionLaneObject
  offLane: MatchStatsLaneReportFactionLaneObject
  safeLane: MatchStatsLaneReportFactionLaneObject
}

type MatchStatsLaneReportFactionLaneObject {
  meleeCount: Int!
  rangeCount: Int!
  siegeCount: Int!
  denyCount: Int!
  neutralCount: Int!
}

type MatchStatsChatEventType {
  time: Int
  type: Int
  fromHeroId: Short
  toHeroId: Short
  value: Short
  pausedTick: Int
  isRadiant: Boolean
}

type MatchStatsTowerDeathType {
  time: Int
  npcId: Short
  isRadiant: Boolean
  attacker: Short
}

type MatchPlaybackDataType {
  courierEvents: [MatchPlaybackDataCourierEventType]
  runeEvents: [MatchPlaybackDataRuneEventType]
  wardEvents: [MatchPlaybackDataWardEventType]
  buildingEvents: [MatchPlaybackDataBuildingEventType]
  towerDeathEvents: [MatchPlaybackDataTowerDeathEventType]
  roshanEvents: [MatchPlaybackDataRoshanEventType]
  radiantCaptainSteamAccountId: Long
  radiantCaptainSteamAccount: SteamAccountType
  direCaptainSteamAccountId: Long
  direCaptainSteamAccount: SteamAccountType
}

type MatchPlaybackDataCourierEventType {
  id: Int!
  ownerHero: Int
  isRadiant: Boolean
  events: [MatchplaybackDataCourierEventObjectType]
}

type MatchplaybackDataCourierEventObjectType {
  time: Int!
  positionX: Int
  positionY: Int
  hp: Int
  isFlying: Boolean
  respawnTime: Int
  didCastBoost: Boolean
  item0Id: Int
  item1Id: Int
  item2Id: Int
  item3Id: Int
  item4Id: Int
  item5Id: Int
}

type MatchPlaybackDataRuneEventType {
  indexId: Int!
  time: Int!
  positionX: Int!
  positionY: Int!
  fromPlayer: Int!
  location: Int!
  rune: Int!
  action: Int!
}

type MatchPlaybackDataWardEventType {
  indexId: Int!
  time: Int!
  positionX: Int!
  positionY: Int!
  fromPlayer: Int
  wardType: WardType
  action: SpawnActionType
  playerDestroyed: Int
}

enum WardType {
  OBSERVER
  SENTRY
}

enum SpawnActionType {
  SPAWN
  DESPAWN
}

type MatchPlaybackDataBuildingEventType {
  time: Int!
  indexId: Int
  type: BuildingType
  hp: Int
  maxHp: Int
  positionX: Int
  positionY: Int
  isRadiant: Boolean
  npcId: Int
  didShrineActivate: Boolean
}

type MatchPlaybackDataTowerDeathEventType {
  time: Int!
  radiant: Int!
  dire: Int!
}

type MatchPlaybackDataRoshanEventType {
  time: Int!
  hp: Int
  maxHp: Int
  createTime: Int
  x: Int
  y: Int
  totalDamageTaken: Int
  item0: Int
  item1: Int
  item2: Int
  item3: Int
  item4: Int
  item5: Int
}

type MatchPlayerSpectatorType {
  steamId: Long
  isRadiantCoach: Boolean
  isVictory: Boolean
}

enum LaneOutcomeEnums {
  TIE
  RADIANT_VICTORY
  RADIANT_STOMP
  DIRE_VICTORY
  DIRE_STOMP
}

input LeagueRequestType {
  """
  A league id to include in this query, excluding all results that do not have this league id.
  """
  leagueId: Int

  """
  An array of league ids to include in this query, excluding all results that do not include one of these leagues.
  """
  leagueIds: [Int]

  """
  An array of tier ids to include in this query, excluding all results that do not include one of these tiers.
  """
  tiers: [LeagueTier]

  """Whether an image is required or not, represented in a boolean."""
  requireImage: Boolean

  """Whether a prize pool is required or not, represented in a boolean."""
  requirePrizePool: Boolean

  """
  Whether a start and end date is required or not, represented in a boolean.
  """
  requireStartAndEndDates: Boolean

  """Whether a league has live matches or not, represented in a boolean."""
  hasLiveMatches: Boolean

  """Whether a league has ended or not, represented in a boolean."""
  leagueEnded: Boolean

  """Whether a league has started or not, represented in a boolean."""
  isFutureLeague: Boolean

  """If a league is set to start after this time."""
  startDateTime: Long

  """If a league is set to end before this time."""
  endDateTime: Long

  """
  Determine to Start value of finding a League Between two specific datetimes.
  """
  betweenStartDateTime: Long

  """
  Determine to End value of finding a League Between two specific datetimes.
  """
  betweenEndDateTime: Long

  """The id to order the results by in this query."""
  orderBy: FilterOrderBy

  """
  The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
  """
  take: Int

  """
  The amount of data to skip before collecting your query. This is useful for Paging.
  """
  skip: Int
}

enum FilterOrderBy {
  LAST_MATCH_TIME
  ID
  NONE
  START_DATE_THEN_TIER
  LAST_MATCH_TIME_THEN_TIER
}

type YogurtQuery {
  """
  Find a match replay upload team by match replay upload team id. matchReplayUploadTeamId is a required input field.
  """
  team(
    """
    The id of the match replay upload team to include in this query, excluding all results that do not include this match replay upload team id.
    """
    matchReplayUploadTeamId: Long!
  ): MatchReplayUploadTeamType

  """
  Find all match replay upload teams associated with the currently logged in user.
  """
  teams: [MatchReplayUploadTeamType]

  """
  Find the defualt match replay upload team associated with the currently logged in user.
  """
  defaultTeam: MatchReplayUploadTeamType

  """
  Find match replay upload team members by match replay upload team id. matchReplayUploadTeamId is a required input field.
  """
  teamMembers(
    """
    The id of the match replay upload team to include in this query, excluding all results that do not include this match replay upload team id.
    """
    matchReplayUploadTeamId: Long!
  ): [MatchReplayUploadTeamMemberType]

  """
  Find match replay uploads by match replay upload team id. matchReplayUploadTeamId and request are required input fields.
  """
  overview(
    """
    The id of the match replay upload team to include in this query, excluding all results that do not include this match replay upload team id.
    """
    matchReplayUploadTeamId: Long!

    """
    The request object filtering which match replay uploads to include in this query, excluding all results that do not pass through this filter.
    """
    request: FilterMatchReplayUploadRequestType
  ): MatchReplayUploadOverviewType

  """
  Find the list of Hero's in the game and determine basic output by grouping them together.
  """
  heroSummary(
    """
    The id of the match replay upload team to include in this query, excluding all results that do not include this match replay upload team id.
    """
    matchReplayUploadTeamId: Long!

    """
    The request object filtering which match replay uploads to include in this query, excluding all results that do not pass through this filter.
    """
    request: FilterMatchReplayUploadRequestType
  ): [MatchReplayUploadHeroSummaryType]
}

type MatchReplayUploadTeamType {
  id: Long!
  name: String!
  email: String!
  teamId: Int!
  creatorCaptainJackIdentityId: Guid
  team: TeamType
  members: [MatchReplayUploadTeamMemberType]
  isDefault: Boolean
}

type MatchReplayUploadTeamMemberType {
  captainJackIdentityId: Guid
  matchUploadTeamId: Long!
  isAdmin: Boolean!
  isDefaultTeam: Boolean!
  steamAccount: SteamAccountType
}

type MatchReplayUploadOverviewType {
  matchCount: Int!
  winCount: Int!
  matches: [MatchReplayUploadMatchType]
}

type MatchReplayUploadMatchType {
  matchUploadTeamId: Long!
  id: Long
  fileName: String!
  uploaderCaptainJackIdentityId: Guid
  isValidated: Boolean!
  isComplete: Boolean!
  isActive: Boolean!
  didRadiantWin: Boolean!
  durationSeconds: Short
  durationMinutes: Int!
  startDateTime: DateTime
  endDateTime: DateTime
  lobbyType: Byte
  numHumanPlayers: Byte
  numHumanSpectators: Byte
  leagueId: Int
  seriesId: Long
  gameMode: Byte
  radiantTeamId: Int
  radiantKills: Byte
  direTeamId: Int
  direKills: Byte
  isRadiantFirstPick: Boolean!
  gameVersionId: Int!
  notes: String
  players: [MatchReplayUploadPlayerType]
  spectators: [Long]
  pickBans: [MatchReplayUploadPickBanType]
  radiantTeam: TeamType
  direTeam: TeamType
  league: LeagueType
}

type MatchReplayUploadPlayerType {
  matchId: Long
  playerSlot: Byte
  matchUploadTeamId: Long!
  steamAccountId: Long
  steamAccount: SteamAccountType
  isRadiant: Boolean!
  isDire: Boolean!
  teamSlot: Byte
  heroId: Short
  kills: Byte
  deaths: Byte
  assists: Byte
  networth: Int!
  lastHits: Short
  denies: Short
  goldPerMinute: Short
  experiencePerMinute: Short
  totalGoldSpent: Int!
  goldSpentOnBuybacks: Int
  goldSpentOnConsumables: Int
  goldSpentOnItems: Int
  goldSpentOnSupport: Int
  heroDamage: Int!
  towerDamage: Int!
  towerKills: Short
  heroHealing: Int!
  level: Byte
  item0Id: Short
  item1Id: Short
  item2Id: Short
  item3Id: Short
  item4Id: Short
  item5Id: Short
  backpack0Id: Short
  backpack1Id: Short
  backpack2Id: Short
  lane: MatchLaneType
  role: MatchPlayerRoleType
  position: MatchPlayerPositionType
  pickOrder: Byte
  teamPickOrder: MatchPlayerTeamPickOrderType
  isVictory: Boolean!
  killsList: [Int]
  assistsList: [Int]
  deathsList: [Int]
  streakList: [Int]
  levelList: [Int]
  totalEarnedGoldList: [Int]
  reliableGoldList: [Int]
  unreliableGoldList: [Int]
  totalEarnedXpList: [Int]
  sharedGoldList: [Int]
  heroKillGoldList: [Int]
  creepKillGoldList: [Int]
  incomeGoldList: [Int]
  networthList: [Int]
  denyCountList: [Int]
  lastHitCountList: [Int]
  lastHitStreakList: [Int]
  lastHitMultiKillList: [Int]
  nearbyCreepDeathCountList: [Int]
  claimedDenyCountList: [Int]
  claimedMissCountList: [Int]
  missCountList: [Int]
  stunsList: [Int]
  heroHealingList: [Int]
  towerKillsList: [Int]
  roshanKillsList: [Int]
  observerWardsPlacedList: [Int]
  sentryWardsPlacedList: [Int]
  creepStackList: [Int]
  campStackList: [Int]
  runePicksupList: [Int]
  goldSpentOnSupportList: [Int]
  heroDamageList: [Int]
  wardsPurchasedList: [Int]
  wardsDestroyedList: [Int]
  commandsIssuedList: [Int]
  goldSpentOnConsumablesList: [Int]
  goldSpentOnItemsList: [Int]
  goldSpentOnBuybacksList: [Int]
  goldLostToDeathList: [Int]
  maxHealthList: [Int]
  maxManaList: [Int]
  bkbChargesUsedList: [Int]
  damageMinList: [Int]
  damageMaxList: [Int]
  damageBonusList: [Int]
  strengthTotalList: [Int]
  agilityTotalList: [Int]
  intellectTotalList: [Int]
  towerDamageList: [Int]
  items: MatchReplayUploadPlayerStatsItemsType
}

enum MatchPlayerTeamPickOrderType {
  FIRST_PICK
  SECOND_PICK
  THIRD_PICK
  FOURTH_PICK
  FIFTH_PICK
}

type MatchReplayUploadPlayerStatsItemsType {
  item0IdList: [Byte]
  item1IdList: [Byte]
  item2IdList: [Byte]
  item3IdList: [Byte]
  item4IdList: [Byte]
  item5IdList: [Byte]
  backpack0IdList: [Byte]
  backpack1IdList: [Byte]
  backpack2IdList: [Byte]
}

type MatchReplayUploadPickBanType {
  playerSlot: Byte
  isPick: Boolean!
  heroId: Short
  bannedHeroId: Short
  time: Byte
  isRadiant: Boolean
  order: Byte
  wasBannedSuccessfully: Boolean!
}

input FilterMatchReplayUploadRequestType {
  withEnemySteamAccount: [Long]
  withFriendHeroId: [Short]
  withEnemyHeroId: [Short]
  withFriendBannedHeroId: [Short]
  withEnemyBannedHeroId: [Short]
  byMatchId: Long
  byMatchIds: [Long]
  byMatchUploadFileName: String
  byMatchUploadUploaderCaptainJackId: Guid
  bySteamAccountId: Long
  bySteamAccountIds: [Long]
  byHeroId: [Short]
  byLeagueId: Int
  bySeriesId: Int
  bySeriesIds: [Long]
  byTeamId: Int
  byGameMode: [Int]
  byLobbyType: [Int]
  byGameVersion: [Int]
  isLeague: Boolean
  isValidated: Boolean
  isComplete: Boolean
  isActive: Boolean
  isVictory: Boolean
  isRadiant: Boolean
  filterPositionIsUs: Boolean
  filterPosition: MatchPlayerPositionType
  filterPositionOrder: [MatchPlayerTeamPickOrderType]
  isRadiantFirstPick: Boolean
  firstPick: Boolean
  minDuration: Int
  maxDuration: Int
  minGameVersionId: Int
  maxGameVersionId: Int
  startDateTime: Long
  endDateTime: Long

  """
  The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
  """
  take: Int

  """
  The amount of data to skip before collecting your query. This is useful for Paging.
  """
  skip: Int
}

type MatchReplayUploadHeroSummaryType {
  heroId: Short
  winCountWith: Int!
  winCountAgainst: Int!
  matchCountWith: Int!
  matchCountAgainst: Int!
  banCountWith: Int!
  banCountAgainst: Int!
  duos: [MatchReplayUploadHeroDuoSummaryType]
}

type MatchReplayUploadHeroDuoSummaryType {
  heroId: Short
  winCountWith: Int!
  winCountAgainst: Int!
  matchCountWith: Int!
  matchCountAgainst: Int!
}

type PlusQuery {
  """
  The main call for STRATZ Plus. It will return back probability data based on a draft of players that were given.
  """
  draft(
    """
    The main call for STRATZ Plus. It will return back probability data based on a draft of players that were given.
    """
    request: PlusDraftRequestType!
  ): PlusDraftType

  """
  Gets a list of data of the players in the match, can send a max of 10 people.  If a user blocks their data on STRATZ, that data will not be returned.
  """
  playerMatchHistory(
    """The request object that will filter your PlusPlayerHover data."""
    request: PlusPlayerHoverRequestType!
  ): PlusHoverType

  """
  Returns back basic data about the user playing a specific hero.  Used in the Draft app to show post-pick data.
  """
  playerHeroHighlight(
    """
    The Steam Account Id to look up. If the person is anonymous, you will get a null.
    """
    steamAccountId: Long!

    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short!
  ): PlayerDraftHeroHighlightType

  """
  Returns a set of events which contain each hero and their averages in each of the respected categories, sorted by rank bracket.
  """
  teamHeroStatus(
    """
    The id of the rank bracket to include in this query, excluding all results that do not include this rank bracket.
    """
    rankBracket: RankBracketBasicEnum!
  ): [PlusHeroTeamStatusDetailType]

  """
  To save CPU cycles we limit the amount of heroes a person can play. If a player picks a hero outside the default list, we have no idea how good the hero would of been. You can call this endpoint to update the grade letter for that hero selection.
  """
  draftMissingLetter(request: PlusDraftMissingLetterRequestType!): PlusLetterType
}

type PlusDraftType {
  midOutcome: Decimal
  safeOutcome: Decimal
  offOutcome: Decimal
  winValues: [Decimal]
  durationValues: [Decimal]
  players: [PlusDraftPlayerType]
}

type PlusDraftPlayerType {
  slot: Byte
  position: MatchPlayerPositionType
  positionValues: [Decimal]
  heroes: [PlusDraftPlayerHeroObjectType]
}

type PlusDraftPlayerHeroObjectType {
  heroId: Short
  pickValue: Decimal
  winValues: [Decimal]
  score: Float
  letter: PlusLetterType
}

input PlusDraftRequestType {
  """
  The match Id or the lobby id of the match your sending.  This will cache data for the next calls to be quicker.
  """
  matchId: Long!

  """A list of all of the banned hero ids in the draft."""
  bans: [Short]

  """
  The game mode for this type. We only support All Pick and Ranked All Pick. In the future Captain's Mode will be supported.
  """
  gameMode: Int!

  """A list of player request objects."""
  players: [PlusDraftPlayerRequestType]!

  """
  Due to Valve changing the way Picking has happened in the past, we require the GameVersionId so we know what version of the network to call.
  """
  gameVersionId: Short!
}

input PlusDraftPlayerRequestType {
  """
  The steam id of the player. This will allow us to find player history on the player if he is not anonymous.
  """
  steamAccountId: Long

  """The slot of player. It is required to be in order from 0-9."""
  slot: Int!

  """
  When a player has selected a hero, this is the id. If a null is sent, we will send back a hero list of possible heroes.
  """
  heroId: Short

  """
  The rank this played is.  In the event he is anonymous, use the lowest rank player in the game.
  """
  rank: Byte

  """
  The role this player will play. If a null is sent, we will assign the best possible role.
  """
  position: MatchPlayerPositionType
}

type PlusHoverType {
  players: [PlusPlayerHoverType]
  bans: [PlusHoverBanType]
}

type PlusPlayerHoverType {
  steamAccount: SteamAccountType
  matchCount: Int
  winCount: Int!
  coreCount: Int
  supportCount: Int
  imp: Int
  heroes: [PlusPlayerHoverHeroType]
  activity: Byte
  languageCode: [String]
  friends: [PlusPlayerHoverPlayerType]
  enemies: [PlusPlayerHoverPlayerType]
  lastMatchDateTime: Long
  heroesExperience: [Short]
  behaviorScore: Short
}

type PlusPlayerHoverHeroType {
  heroId: Short
  winCount: Int!
  lossCount: Int!
}

type PlusPlayerHoverPlayerType {
  steamAccountId: Long
  matchCount: Int!
  winCount: Int!
  lastMatchDateTime: Long
}

type PlusHoverBanType {
  heroId: Short
  score: Decimal
  flags: Byte
}

input PlusPlayerHoverRequestType {
  """
  An array of steam account ids to limit the query to only return matches with these steam account ids.
  """
  steamAccountIds: [Long]!

  """
  An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
  """
  gameModeIds: [Byte]

  """
  An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types.
  """
  lobbyTypeIds: [Byte]

  """The amount of matches to have returned in your query. Max : """
  take: Int!

  """
  Should our Networks attempt to try to make Radiant Win the draft or Dire.
  """
  shouldRadiantWin: MatchPlayerPositionType
}

type PlayerDraftHeroHighlightType {
  lastPlayed: Long
  winCount: Int
  matchCount: Int
  impAllTime: Int
  mvpCountLastMonth: Int
  topCoreCountLastMonth: Int
  topSupportCountLastMonth: Int
  winCountLastMonth: Int
  matchCountLastMonth: Int
  impLastMonth: Int
  winCountLastSixMonths: Int
  matchCountLastSixMonths: Int
  impLastSixMonths: Int
}

type PlusHeroTeamStatusDetailType {
  heroId: Int!
  basicBracket: RankBracketBasicEnum
  position: MatchPlayerPositionType
  averages: PlusHeroTeamStatusAveragesType
}

type PlusHeroTeamStatusAveragesType {
  cs: Decimal
  deaths: Decimal
  towerDamage: Decimal
  physicalDamage: Decimal
  magicalDamage: Decimal
  physicalDamageReceived: Decimal
  magicalDamageReceived: Decimal
  disableCount: Decimal
  disableDuration: Decimal
  stunCount: Decimal
  stunDuration: Decimal
  slowCount: Decimal
  slowDuration: Decimal
  healingAllies: Decimal
  purgeModifiers: Decimal
  weakenCount: Decimal
  weakenDuration: Decimal
  pureDamageReceived: Decimal
  pureDamage: Decimal
}

input PlusDraftMissingLetterRequestType {
  """A list of all of the banned hero ids in the draft."""
  bans: Short!

  """
  The game mode for this type. We only support All Pick and Ranked All Pick. In the future Captain's Mode will be supported.
  """
  gameMode: Int!

  """A list of player request objects."""
  players: [PlusDraftPlayerRequestType]

  """
  Due to Valve changing the way Picking has happened in the past, we require the GameVersionId so we know what version of the network to call.
  """
  gameVersionId: Short!
}

type StratzQuery {
  admin: AdminQuery
  user: UserQuery
  page: PageQuery

  """Returns a list of Stratz blogs."""
  blogs(
    """
    The amount of data to skip before collecting your query. This is useful for Paging.
    """
    skip: Int

    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int
  ): [BlogType]

  """Returns a list of News Items released by Dota 2 directly."""
  news: [NewsItemType]

  """
  Home page data that shows the total count of players and matches in our database.
  """
  ticker: [Int]

  """
  Shows the availability to major components required in the STRATZ foundation.
  """
  status: ServerStatusType

  """
  Returns a list of languages and an Id for reference. This is used throughout the site.
  """
  languages: [LanguageType]

  """Returns a list of Stratz blogs."""
  matchRetry(
    """
    The id of the Dota match to include in this query, excluding all results that do not include this id.
    """
    id: Long!
  ): Boolean
  search(request: FilterSearchRequestType): SearchType
}

type AdminQuery {
  """Returns a list of Stratz blogs."""
  apiMemoryReport: [String]
}

type UserQuery {
  """Find user details of the currently logged in user."""
  profile: UserType

  """Returns a list of Stratz blogs."""
  homepage(
    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int!
  ): UserHomepageType

  """Gets the list of followers the person is following."""
  followers: [FollowerType]

  """Gets the list of followers the person is following."""
  following: [FollowerType]

  """Returns a list of feed events for the logged in user."""
  feed(
    """
    The amount of data to skip before collecting your query. This is useful for Paging.
    """
    skip: Int

    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int
  ): FeedResponseType
}

type UserType {
  profile: CaptainJackIdentityPrivateProfileType
  steamAccount: SteamAccountType
  recentMatch: MatchType
  followingCount: Int
  followerCount: Int
  followingLeagueCount: Int
  followingTeamCount: Int
  stratzApiApplications: [CaptainJackIdentityApiApplicationType]
}

type CaptainJackIdentityPrivateProfileType {
  captainJackIdentityId: Guid
  name: String
  twitter: String
  facebook: String
  twitch: String
  youTube: String
  premiumEndDate: Long
  isAdmin: Boolean
  feedLevel: Byte
  emailLevel: Byte
  dailyEmail: Boolean!
  weeklyEmail: Boolean!
  monthlyEmail: Boolean!
  proCircuitFeedLevel: Byte
  proCircuitEmailLevel: Byte
  themeType: Byte
  languageId: Byte
  emailValidationCode: String
  isEmailValidated: Boolean!
  emailHour: Byte
  lastReadFeedTime: Long
  lastDailyEmail: Long
  lastWeeklyEmail: Long
  lastMonthlyEmail: Long
  lastLeagueDailyEmail: Long
  lastTeamDailyEmail: Long
  lastProCircuitDailyEmail: Long
  unsubscribeCode: String
  lastSeen: Long
}

type CaptainJackIdentityApiApplicationType {
  captainJackIdentityId: Guid
  tokenType: StratzApiType
  emailAddress: String
  discordAddress: String
  websiteAddress: String
  description: String
  isApproved: Boolean
  apiKey: String
  secretKey: String
  issuer: String
  matomoReferenceToken: String
}

enum StratzApiType {
  DATA_COLLECTOR
  MULTI_KEY
}

type UserHomepageType {
  """A list of blog components to be displayed separately on the homepage."""
  blogs(
    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int

    """
    The amount of data to skip before collecting your query. This is useful for Paging.
    """
    skip: Int

    """
    An array of blog ids to exclude in this query, including all results that do not include one of these blogs.
    """
    excludedBlogIds: [Int]
  ): [BlogType]
  upcomingLeagues(
    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int

    """
    The amount of data to skip before collecting your query. This is useful for Paging.
    """
    skip: Int

    """
    An array of league ids to exclude in this query, including all results that do not include one of these leagues.
    """
    excludedLeagueIds: [Int]

    """
    An array of league ids to include in this query, excluding all results that do not include one of these leagues.
    """
    includedLeagueIds: [Int]

    """
    An array of league tier ids to include in this query, excluding all results that do not include one of these league tiers.
    """
    includedLeagueTierIds: [Int]
  ): [LeagueType]
  inProgressLeagues(
    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int

    """
    The amount of data to skip before collecting your query. This is useful for Paging.
    """
    skip: Int

    """
    An array of league ids to exclude in this query, including all results that do not include one of these leagues.
    """
    excludedLeagueIds: [Int]

    """
    An array of league ids to include in this query, excluding all results that do not include one of these leagues.
    """
    includedLeagueIds: [Int]

    """
    An array of league tier ids to include in this query, excluding all results that do not include one of these league tiers.
    """
    includedLeagueTierIds: [Int]
  ): [LeagueType]
  leagueMetas(
    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int

    """
    The amount of data to skip before collecting your query. This is useful for Paging.
    """
    skip: Int

    """
    An array of league ids to exclude in this query, including all results that do not include one of these leagues.
    """
    excludedLeagueIds: [Int]

    """
    An array of league ids to include in this query, excluding all results that do not include one of these leagues.
    """
    includedLeagueIds: [Int]

    """
    An array of league tier ids to include in this query, excluding all results that do not include one of these league tiers.
    """
    includedLeagueTierIds: [Int]
  ): [LeagueMetaType]
  topProPlayers(
    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int

    """
    The amount of data to skip before collecting your query. This is useful for Paging.
    """
    skip: Int
  ): [ProPlayerFollowType]
  topPlayersByHeroType(
    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    heroComponentsTake: Int

    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    playersTake: Int

    """
    An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
    """
    heroIds: Int

    """
    An array of rank bracket ids to include in this query, excluding all results that do not include one of these rank brackets.
    """
    rankBracketIds: Int
  ): [TopPlayersByHeroType]
  topSynergiesByHero(
    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    synergyComponentsTake: Int

    """
    An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
    """
    heroIds: Int
  ): [HomepageHeroSynergyType]
  matchAwards(
    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int

    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    skip: Int

    """
    An array of award ids to include in this query, excluding all results that do not include one of these awards. The player award types include MVP (1), Top Core (2), and Top Support (3).
    """
    matchPlayerAwardTypeIds: [Byte]
  ): [HomepageHeroSynergyType]
  recentRampages(
    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int

    """
    The amount of data to skip before collecting your query. This is useful for Paging.
    """
    skip: Int
  ): [HomepageHeroSynergyType]
  recentWinStreaks(
    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int

    """
    The amount of data to skip before collecting your query. This is useful for Paging.
    """
    skip: Int
  ): [HomepageHeroSynergyType]
  recentHighImps(
    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int

    """
    The amount of data to skip before collecting your query. This is useful for Paging.
    """
    skip: Int
  ): [HomepageHeroSynergyType]
  recentMatches(
    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int

    """
    The amount of data to skip before collecting your query. This is useful for Paging.
    """
    skip: Int
  ): [HomepageHeroSynergyType]
  activeLeagueGames(
    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int

    """
    The amount of data to skip before collecting your query. This is useful for Paging.
    """
    skip: Int
  ): [HomepageHeroSynergyType]
  topLiveGames(
    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int

    """
    The amount of data to skip before collecting your query. This is useful for Paging.
    """
    skip: Int
  ): [HomepageHeroSynergyType]
  totalComponents: Int
}

type BlogType {
  id: Byte
  captainJackIdentityId: Guid
  title: String!
  bannerImageUrl: String!
  data: String!
  liveDateTime: DateTime
  link: String!
}

type LeagueMetaType {
  leagueId: Int
  bestRecord: LeagueMetaDetailType
  mostPicked: LeagueMetaDetailType
  mostBanned: LeagueMetaDetailType
  missingMatchCount: Int
  totalMatchCount: Int
  league: LeagueType
}

type LeagueMetaDetailType {
  heroId: Short
  winCount: Int
  lossCount: Int
  winRate: Decimal
  pickRate: Decimal
  pickCount: Int
  banRate: Decimal
  banCount: Int
}

type ProPlayerFollowType {
  steamAccountId: Long
  activity: Int
  steamAccount: SteamAccountType
}

type TopPlayersByHeroType {
  heroId: Short
  players: [PlayerLeaderBoardByHeroType]
}

type PlayerLeaderBoardByHeroType {
  heroId: Short
  seasonBracket: Byte
  steamAccountId: Long
  steamAccount: SteamAccountType
  impAverage: Byte
  position: MatchPlayerPositionType
  wins: Byte
  losses: Byte
  winStreak: Byte
  regionId: Byte
  changeInRanking: Short
  createdDateTime: Long
}

type HomepageHeroSynergyType {
  mainHeroId: Short
  mainHeroBaseWinRate: Decimal
  heroDryads: [HomepageHeroDryadType]
}

type HomepageHeroDryadType {
  mainHeroId: Short
  comparisonHeroId: Short
  bracketBasicIds: RankBracketBasicEnum
  matchCount: Long
  winCount: Long
  synergy: Decimal
  winsAverage: Decimal
  comparisonHeroBaseWinRate: Decimal
}

type FollowerType {
  captainJackIdentityId: Guid
  steamAccountId: Long
  feedLevel: Byte
  emailLevel: Byte
  dailyEmail: Boolean
  weeklyEmail: Boolean
  monthlyEmail: Boolean
  isFavorite: Boolean
  lastEmail: Long
  didManualUpdate: Boolean!
  steamAccount: SteamAccountType
  captainJackIdentity: CaptainJackIdentityType
}

type CaptainJackIdentityType {
  id: Guid
  steamAccountId: Long
  steamAccount: SteamAccountType
  profile: CaptainJackIdentityPublicProfileType
}

type FeedResponseType {
  data: [FeedType]
  count: Int
  attackAnimationPoint: DateTime
}

type FeedType {
  steamAccount: SteamAccountType
  league: LeagueType
  targetSteamAccountId: Long
  type: Byte
  matchId: Long
  heroId: Int!
  date: Long
  value: Int!
  didWin: Boolean
}

type PageQuery {
  """
  STRATZ specific endpoints found on the /player/ section of the website. id is a required input field.
  """
  player(
    """
    The steam account id to include in this query, excluding all results that do not have this steam account id.
    """
    steamAccountId: Long!
  ): PagePlayerQuery

  """
  STRATZ specific endpoints found on the /players/ section of the website. 
  """
  players: PagePlayersQuery

  """
  STRATZ specific endpoints found on the /matches/ section of the website. 
  """
  matches: PageMatchesQuery

  """
  STRATZ specific endpoints found on the /leagues/ section of the website. 
  """
  leagues: PageLeaguesQuery

  """Endpoints for the TI10 (2020) regarding the summer event."""
  aghanim: PageAghanimQuery

  """Endpoints for Imp Related calls."""
  imp: ImpQuery
  direTide: PageDireTideQuery

  """Endpoints for the battlepass data."""
  battlePass: PageBattlepassQuery
}

type PagePlayerQuery {
  """Returns the violations commited by a player in their last 500 games."""
  conduct: PlayerConductResponseType

  """Get very simple data for the on-hover of a player icon."""
  simpleSummary: PlayerCardHoverType

  """
  Provided in-depth look of a player and how they proform globally on all heroes.
  """
  performance(
    """
    The request object used to filter matches returned based on input criteria.
    """
    request: PlayerPerformanceMatchesRequestType!
  ): PlayerPerformanceType

  """A more in depth at a single player's single hero performance."""
  heroPerformance(
    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short!

    """
    The request object used to filter matches returned based on input criteria.
    """
    request: PlayerHeroPerformanceMatchesRequestType!
  ): PlayerPerformanceType

  """
  Returns a list of all heroes played by the steam account id and contains data about the average performance.
  """
  heroesPerformance(
    """
    The request object used to filter matches returned based on input criteria.
    """
    request: PlayerHeroesPerformanceMatchesRequestType
  ): [PlayerHeroesPerformanceType]

  """
  Picked the top pros and annoucers and determines if you ever have played with them and when.
  """
  playedWithPro: PlayerPlayedWithProType

  """Returns a general player summary of random set of predefinded filters."""
  breakdown(
    """
    The request object used to filter matches returned based on input criteria.
    """
    request: PlayerBreakdownRequestType!
  ): PlayerBreakdownType

  """Returns a list of players that the player has played with."""
  peers(
    """
    The request object used to filter matches returned based on input criteria.
    """
    request: PlayerTeammatesGroupByRequestType!

    """
    Normally, you use Take inside the request object.  But due to Take being used to determine how many matches to look at, this take will limit the amount of rows being returned from the results.
    """
    take: Int

    """
    Normally, you use Skip inside the request object.  But due to Skip being used to determine how many matches to look at, this skip will skip the amount of rows being returned from the results.
    """
    skip: Int
  ): [PlayerTeammateType]
}

type PlayerConductResponseType {
  lastIncidentDateTime: Long
  lastIncidentMatchId: Long
  recentMatchIncidents: [Short]
  behaviorScore: Short
}

input PlayerPerformanceMatchesRequestType {
  """An array of Dota match ids to include in this query."""
  matchIds: [Long]

  """
  A league id to include in this query, excluding all results that do not have this league id.
  """
  leagueId: Int

  """
  A series id to include in this query, excluding all results that do not have this series id.
  """
  seriesId: Long

  """
  A team id to include in this query, excluding all results that do not have this team id.
  """
  teamId: Int

  """
  Whether STRATZ has yet parsed the data of the match or not, represented in a boolean.
  """
  isParsed: Boolean

  """Whether the match is a league match or not."""
  isLeague: Boolean

  """Whether the match has a team assigned or not."""
  isTeam: Boolean

  """
  The start DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  startDateTime: Long

  """
  The end DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  endDateTime: Long

  """
  An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
  """
  gameModeIds: [Byte]

  """
  An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types.
  """
  lobbyTypeIds: [Byte]

  """
  An array of game version ids to include in this query, excluding all results that do not include one of these game versions.
  """
  gameVersionIds: [Int]

  """
  When searching for a league, the tier the league must be in. Tiers: Amateur = 1, Professional = 2, Premium = 3, Pro Circuit = 4, Main Event = 5
  """
  tier: [Int]

  """
  An array of region ids to include in this query, excluding all results that do not include one of these regions.
  """
  regionIds: [Int]

  """
  An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-80 with 0 being unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars.
  """
  rankIds: [Int]

  """
  STRATZ applys an formula to determine if a game is considered 'real'. We attempt to detect AFKers, leavers, feeders, etc. 'IsStats' will return matches that do not include any of these poor quality matches.
  """
  isStats: Boolean

  """
  An array of lane ids (enum MatchLaneType) to include in this query, excluding all results that do not include one of these lanes. Roaming = 0, SafeLane = 1, Midlane = 2, Offlane = 3, Jungle = 4
  """
  laneIds: [Int]

  """
  An array of role ids (enum MatchPlayerRoleType) to include in this query, excluding all results that do not include one of these roles. Core = 0, Light Support = 1, Hard Support = 2
  """
  roleIds: [Int]

  """
  An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes.
  """
  positionIds: [MatchPlayerPositionType]

  """
  An array of award ids to include in this query, excluding all results that do not include one of these awards. The player award types include MVP (1), Top Core (2), and Top Support (3).
  """
  awardIds: [Int]

  """Include all matches that are party games, excluding all others."""
  isParty: Boolean

  """
  STRATZ gives 3 players in each game an award for playing well. MVP, Top Core, Top Support (enum MatchPlayerAwardType). If you include a query of 'steamAccountId' then it will require that player to have gotten at least 1 of these awards for each match result.
  """
  hasAward: Boolean

  """Whether the match was a victory or not for the specified player."""
  isVictory: Boolean

  """Whether the specified player was on Radiant or not."""
  isRadiant: Boolean

  """
  An array of steam account ids found on your team to include in this query, excluding all results that do not include one of these steam accounts found on your team.
  """
  withFriendSteamAccountIds: [Long]

  """
  An array of hero ids found on your team to include in this query, excluding all results that do not include one of these heroes found on your team.
  """
  withFriendHeroIds: [Int]
}

input PlayerHeroesPerformanceMatchesRequestType {
  """An array of Dota match ids to include in this query."""
  matchIds: [Long]

  """
  A league id to include in this query, excluding all results that do not have this league id.
  """
  leagueId: Int

  """
  A series id to include in this query, excluding all results that do not have this series id.
  """
  seriesId: Long

  """
  A team id to include in this query, excluding all results that do not have this team id.
  """
  teamId: Int

  """
  Whether STRATZ has yet parsed the data of the match or not, represented in a boolean.
  """
  isParsed: Boolean

  """Whether the match is a league match or not."""
  isLeague: Boolean

  """Whether the match has a team assigned or not."""
  isTeam: Boolean

  """
  Requests matches where the match is at least this many minutes. Default is null and there is no minimum.
  """
  minDuration: Int

  """
  Requests matches where the match is no longer than this many minutes.  Default is null and there is no maximum.
  """
  maxDuration: Int

  """
  The start DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  startDateTime: Long

  """
  The end DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  endDateTime: Long

  """
  An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
  """
  gameModeIds: [Byte]

  """
  An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types.
  """
  lobbyTypeIds: [Byte]

  """
  An array of game version ids to include in this query, excluding all results that do not include one of these game versions.
  """
  gameVersionIds: [Int]

  """
  Requests matches where the match is at least than this input.  See GameVersion API call for a list of patch ids. Default is null and there is no minimum.
  """
  minGameVersionId: Int

  """
  Requests matches where the match is lower than this input.  See GameVersion API call for a list of patch ids. Default is null and there is no maximum.
  """
  maxGameVersionId: Int

  """
  An array of region ids to include in this query, excluding all results that do not include one of these regions.
  """
  regionIds: [Int]

  """
  An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-80 with 0 being unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars.
  """
  rankIds: [Int]

  """
  STRATZ applys an formula to determine if a game is considered 'real'. We attempt to detect AFKers, leavers, feeders, etc. 'IsStats' will return matches that do not include any of these poor quality matches.
  """
  isStats: Boolean

  """
  An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
  """
  heroIds: [Short]

  """
  An array of lane ids (enum MatchLaneType) to include in this query, excluding all results that do not include one of these lanes. Roaming = 0, SafeLane = 1, Midlane = 2, Offlane = 3, Jungle = 4
  """
  laneIds: [Int]

  """
  An array of role ids (enum MatchPlayerRoleType) to include in this query, excluding all results that do not include one of these roles. Core = 0, Light Support = 1, Hard Support = 2
  """
  roleIds: [Int]

  """
  An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes.
  """
  positionIds: [MatchPlayerPositionType]

  """
  An array of award ids to include in this query, excluding all results that do not include one of these awards. The player award types include MVP (1), Top Core (2), and Top Support (3).
  """
  awardIds: [Int]

  """Include all matches that are party games, excluding all others."""
  isParty: Boolean

  """Whether the specified player was on Radiant or not."""
  isRadiant: Boolean

  """
  Matches where the user is in a party with this many friends. Automatically applys IsParty = true. This is an array input.
  """
  partyCounts: [Int]

  """
  STRATZ gives 3 players in each game an award for playing well. MVP, Top Core, Top Support (enum MatchPlayerAwardType). If you include a query of 'steamAccountId' then it will require that player to have gotten at least 1 of these awards for each match result.
  """
  hasAward: Boolean

  """
  An array of steam account ids found on your team to include in this query, excluding all results that do not include one of these steam accounts found on your team.
  """
  withFriendSteamAccountIds: [Long]

  """
  An array of hero ids found on your team to include in this query, excluding all results that do not include one of these heroes found on your team.
  """
  withFriendHeroIds: [Int]
}

type PlayerPlayedWithProType {
  playedCount: Int!
  totalCount: Int!
  casters: [PlayerPlayedWithProPlayerType]
  teams: [PlayerPlayedWithProTeamType]
  internationalWinners: [PlayerPlayedWithProTeamType]
}

type PlayerPlayedWithProPlayerType {
  steamId: Long
  steamAccount: SteamAccountType
  with: PlayerPlayedWithProPlayerMatchType
  vs: PlayerPlayedWithProPlayerMatchType
}

type PlayerPlayedWithProPlayerMatchType {
  matchId: Long
  match: MatchType
}

type PlayerPlayedWithProTeamType {
  teamId: Int!
  teamLogo: String!
  teamName: String!
  players: [PlayerPlayedWithProPlayerType]
}

type PlayerBreakdownType {
  matches: PlayerBreakdownObjectType
  isStatsMatches: [PlayerBreakdownObjectType]
  rankMatches: [PlayerBreakdownObjectType]
  lobbyMatches: [PlayerBreakdownObjectType]
  gameModeMatches: [PlayerBreakdownObjectType]
  factionMatches: [PlayerBreakdownObjectType]
  regionMatches: [PlayerBreakdownObjectType]
  laneMatches: [PlayerBreakdownObjectType]
  roleMatches: [PlayerBreakdownObjectType]
  partyMatches: [PlayerBreakdownObjectType]
  impMatches: [PlayerBreakdownObjectType]
  durationMatches: [PlayerBreakdownObjectType]
  heroAttributeMatches: [PlayerBreakdownObjectType]
  dayOfWeekMatches: [PlayerBreakdownObjectType]
  timeOfDayMatches: [PlayerBreakdownObjectType]
  weekEndMatches: [PlayerBreakdownObjectType]
}

type PlayerBreakdownObjectType {
  id: Int
  matchCount: Int!
  win: Int
  imp: Int
  lastSeenDateTime: Long
}

input PlayerBreakdownRequestType {
  """An array of Dota match ids to include in this query."""
  matchIds: [Long]

  """
  A league id to include in this query, excluding all results that do not have this league id.
  """
  leagueId: Int

  """
  A series id to include in this query, excluding all results that do not have this series id.
  """
  seriesId: Long

  """
  A team id to include in this query, excluding all results that do not have this team id.
  """
  teamId: Int

  """
  Whether STRATZ has yet parsed the data of the match or not, represented in a boolean.
  """
  isParsed: Boolean

  """Whether the match is a league match or not."""
  isLeague: Boolean

  """Whether the match has a team assigned or not."""
  isTeam: Boolean

  """
  Requests matches where the match is at least this many minutes. Default is null and there is no minimum.
  """
  minDuration: Int

  """
  Requests matches where the match is no longer than this many minutes.  Default is null and there is no maximum.
  """
  maxDuration: Int

  """
  The start DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  startDateTime: Long

  """
  The end DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  endDateTime: Long

  """
  An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
  """
  gameModeIds: [Byte]

  """
  An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types.
  """
  lobbyTypeIds: [Byte]

  """
  An array of game version ids to include in this query, excluding all results that do not include one of these game versions.
  """
  gameVersionIds: [Int]

  """
  Requests matches where the match is at least than this input.  See GameVersion API call for a list of patch ids. Default is null and there is no minimum.
  """
  minGameVersionId: Int

  """
  Requests matches where the match is lower than this input.  See GameVersion API call for a list of patch ids. Default is null and there is no maximum.
  """
  maxGameVersionId: Int

  """
  An array of region ids to include in this query, excluding all results that do not include one of these regions.
  """
  regionIds: [Int]

  """
  An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-80 with 0 being unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars.
  """
  rankIds: [Int]

  """
  STRATZ applys an formula to determine if a game is considered 'real'. We attempt to detect AFKers, leavers, feeders, etc. 'IsStats' will return matches that do not include any of these poor quality matches.
  """
  isStats: Boolean

  """
  An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
  """
  heroIds: [Short]

  """
  An array of lane ids (enum MatchLaneType) to include in this query, excluding all results that do not include one of these lanes. Roaming = 0, SafeLane = 1, Midlane = 2, Offlane = 3, Jungle = 4
  """
  laneIds: [Int]

  """
  An array of role ids (enum MatchPlayerRoleType) to include in this query, excluding all results that do not include one of these roles. Core = 0, Light Support = 1, Hard Support = 2
  """
  roleIds: [Int]

  """
  An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes.
  """
  positionIds: [MatchPlayerPositionType]

  """
  An array of award ids to include in this query, excluding all results that do not include one of these awards. The player award types include MVP (1), Top Core (2), and Top Support (3).
  """
  awardIds: [Int]

  """Include all matches that are party games, excluding all others."""
  isParty: Boolean

  """Whether the specified player was on Radiant or not."""
  isRadiant: Boolean

  """
  Matches where the user is in a party with this many friends. Automatically applys IsParty = true. This is an array input.
  """
  partyCounts: [Int]

  """
  STRATZ gives 3 players in each game an award for playing well. MVP, Top Core, Top Support (enum MatchPlayerAwardType). If you include a query of 'steamAccountId' then it will require that player to have gotten at least 1 of these awards for each match result.
  """
  hasAward: Boolean

  """
  An array of steam account ids found on your team to include in this query, excluding all results that do not include one of these steam accounts found on your team.
  """
  withFriendSteamAccountIds: [Long]

  """
  An array of hero ids found on your team to include in this query, excluding all results that do not include one of these heroes found on your team.
  """
  withFriendHeroIds: [Int]
}

type PlayerTeammateType {
  steamAccountId: Long
  steamAccount: SteamAccountType
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
  lastMatchDateTime: Long
  firstMatchDateTime: Long
}

input PlayerTeammatesGroupByRequestType {
  """
  Only used when doing matchesGroupBy endpoint.  This is how the data will be grouped and makes your return Id field.
  """
  playerTeammateSort: FilterPlayerTeammateEnum!
  matchGroupOrderBy: FilterMatchGroupOrderByEnum!

  """If the return should be ordered by Ascending or Desending order."""
  orderBy: FindMatchPlayerOrderBy!

  """An array of Dota match ids to include in this query."""
  matchIds: [Long]

  """
  A league id to include in this query, excluding all results that do not have this league id.
  """
  leagueId: Int

  """
  A series id to include in this query, excluding all results that do not have this series id.
  """
  seriesId: Long

  """
  A team id to include in this query, excluding all results that do not have this team id.
  """
  teamId: Int

  """
  When requesting matches with a primary SteamAccountId, this will ensure that player is on specific team Id being sent in.
  """
  teamIdSteamAccount: Int

  """
  Whether STRATZ has yet parsed the data of the match or not, represented in a boolean.
  """
  isParsed: Boolean

  """
  The start DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  startDateTime: Long

  """
  The end DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  endDateTime: Long

  """
  An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
  """
  gameModeIds: [Byte]

  """
  An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types.
  """
  lobbyTypeIds: [Byte]

  """
  An array of game version ids to include in this query, excluding all results that do not include one of these game versions.
  """
  gameVersionIds: [Int]

  """
  An array of region ids to include in this query, excluding all results that do not include one of these regions.
  """
  regionIds: [Int]

  """
  An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-80 with 0 being unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars.
  """
  rankIds: [Int]

  """
  An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
  """
  bracketIds: [Int]

  """
  STRATZ applys an formula to determine if a game is considered 'real'. We attempt to detect AFKers, leavers, feeders, etc. 'IsStats' will return matches that do not include any of these poor quality matches.
  """
  isStats: Boolean

  """
  An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
  """
  heroIds: [Short]

  """
  An array of lane ids (enum MatchLaneType) to include in this query, excluding all results that do not include one of these lanes. Roaming = 0, SafeLane = 1, Midlane = 2, Offlane = 3, Jungle = 4
  """
  laneIds: [Int]

  """
  An array of role ids (enum MatchPlayerRoleType) to include in this query, excluding all results that do not include one of these roles. Core = 0, Light Support = 1, Hard Support = 2
  """
  roleIds: [Int]

  """
  An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes.
  """
  positionIds: [MatchPlayerPositionType]

  """
  An array of award ids to include in this query, excluding all results that do not include one of these awards. The player award types include MVP (1), Top Core (2), and Top Support (3).
  """
  awardIds: [Int]

  """Include all matches that are party games, excluding all others."""
  isParty: Boolean

  """
  STRATZ gives 3 players in each game an award for playing well. MVP, Top Core, Top Support (enum MatchPlayerAwardType). If you include a query of 'steamAccountId' then it will require that player to have gotten at least 1 of these awards for each match result.
  """
  hasAward: Boolean

  """
  An array of steam account ids found on your team to include in this query, excluding all results that do not include one of these steam accounts found on your team.
  """
  withFriendSteamAccountIds: [Long]

  """
  An array of hero ids found on your team to include in this query, excluding all results that do not include one of these heroes found on your team.
  """
  withFriendHeroIds: [Int]

  """
  Requests matches where the match is at least than this input.  See GameVersion API call for a list of patch ids. Default is null and there is no minimum.
  """
  minGameVersionId: Int

  """
  Requests matches where the match is lower than this input.  See GameVersion API call for a list of patch ids. Default is null and there is no maximum.
  """
  maxGameVersionId: Int

  """Minimum amount of MatchCount required for a Duo to qualify"""
  matchLimitMin: Int

  """Minimum amount of MatchCount required for a Duo to qualify"""
  matchLimitMax: Int

  """
  Include only results where the main player played with popular broadcasters.
  """
  onlyCasters: Boolean

  """
  Include only results where main player played with popular professionals.
  """
  onlyPros: Boolean

  """The amount of matches to have returned in your query. Max : """
  take: Int

  """
  The amount of matches to skip before collecting your query. Hint: Paging
  """
  skip: Int
}

enum FilterPlayerTeammateEnum {
  WITH
  AGAINST
}

type PagePlayersQuery {
  """
  Endpoint which breaks down all the SteamAccounts in the database by their current season rank.
  """
  steamAccountByRank: [SteamAccountByRankType]
}

type SteamAccountByRankType {
  rank: Short!
  playerCount: Int!
}

type PageMatchesQuery {
  """Returns the last 12 hours by hour showing the amount of matches."""
  matchesStatsHour(
    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int

    """
    An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-80 with 0 being unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars.
    """
    bracketIds: [RankBracket]

    """
    An array of region ids to include in this query, excluding all results that do not include one of these regions.
    """
    regionIds: [BasicRegionType]

    """
    An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
    """
    gameModeIds: [GameModeEnumType]
  ): [MatchesHourType]

  """Returns the last 12 days by day showing the amount of matches."""
  matchesStatsDay(
    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int

    """
    An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-80 with 0 being unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars.
    """
    bracketIds: [RankBracket]

    """
    An array of region ids to include in this query, excluding all results that do not include one of these regions.
    """
    regionIds: [BasicRegionType]

    """
    An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
    """
    gameModeIds: [GameModeEnumType]
  ): [MatchesDayType]

  """Returns the last 12 weeks by week showing the amount of matches."""
  matchesStatsWeek(
    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int

    """
    An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-80 with 0 being unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars.
    """
    bracketIds: [RankBracket]

    """
    An array of region ids to include in this query, excluding all results that do not include one of these regions.
    """
    regionIds: [BasicRegionType]

    """
    An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
    """
    gameModeIds: [GameModeEnumType]
  ): [MatchesWeekType]

  """Returns the data by month showing the amount of matches."""
  matchesStatsMonth(
    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int

    """
    An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-80 with 0 being unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars.
    """
    bracketIds: [RankBracket]

    """
    An array of region ids to include in this query, excluding all results that do not include one of these regions.
    """
    regionIds: [BasicRegionType]

    """
    An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
    """
    gameModeIds: [GameModeEnumType]
  ): [MatchesMonthType]

  """Returns the data by game version showing the amount of matches."""
  matchesStatsGameVersion(
    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int

    """
    An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-80 with 0 being unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars.
    """
    bracketIds: [RankBracket]

    """
    An array of region ids to include in this query, excluding all results that do not include one of these regions.
    """
    regionIds: [BasicRegionType]

    """
    An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
    """
    gameModeIds: [GameModeEnumType]
  ): [MatchesGameVersionType]

  """
  Amount of players who are active and searching for a game in this region.
  """
  matchmakingStats: [MatchmakingStatsType]
}

type MatchesHourType {
  hour: Long!
  matchCount: Int!
}

enum RankBracket {
  UNCALIBRATED
  HERALD
  GUARDIAN
  CRUSADER
  ARCHON
  LEGEND
  ANCIENT
  DIVINE
  IMMORTAL
}

enum BasicRegionType {
  CHINA
  SEA
  NORTH_AMERICA
  SOUTH_AMERICA
  EUROPE
}

type MatchesDayType {
  day: Long!
  matchCount: Int!
}

type MatchesWeekType {
  week: Long!
  matchCount: Int!
}

type MatchesMonthType {
  month: Long!
  matchCount: Int!
}

type MatchesGameVersionType {
  gameVersionId: Short!
  matchCount: Int!
}

type MatchmakingStatsType {
  time: Long!
  uSWest: Int!
  uSEast: Int!
  europe: Int!
  singapore: Int!
  brazil: Int!
  stockholm: Int!
  austria: Int!
  australia: Int!
  southAfrica: Int!
  perfectWorldTelecom: Int!
  perfectWorldUnicom: Int!
  dubai: Int!
  chile: Int!
  peru: Int!
  india: Int!
  perfectWorldTelecomGuangdong: Int!
  perfectWorldTelecomZhejiang: Int!
  japan: Int!
  perfectWorldTelecomWuhan: Int!
  taiwan: Int!
  perfectWorldUnicomTianjin: Int!
}

type PageLeaguesQuery {
  """Returns the last 12 hours by hour showing the amount of matches."""
  dpcPositionStats: [LeagueDpcPositionStatObjectType]
}

type LeagueDpcPositionStatObjectType {
  position: MatchPlayerPositionType
  matchCount: Int
  avgKills: Float
  avgDeaths: Float
  avgAssists: Float
}

type PageAghanimQuery {
  """Returns a match by Id based on the Event Aghanim Labyrinth."""
  match(
    """
    The id of the Dota match to include in this query, excluding all results that do not include this id.
    """
    id: Long!
  ): AghanimLabMatchType

  """Returns a list of matches by based on the Event Aghanim Labyrinth."""
  matches(request: FilterAghanimLabMatchRequestType): [AghanimLabMatchType]

  """
  Returns all the combinations of Heroes and their success on the Event Aghanim Labyrinth.
  """
  heroCompositions(request: FilterAghanimLabHeroCompositionRequestType!): [AghanimLabHeroCompositionType]

  """
  Returns all the combinations of Heroes and their success on the Event Aghanim Labyrinth.
  """
  heroComposition(heroIds: [Short]!, difficulty: AghanimLabMatchDifficultyEnum!): AghanimLabHeroCompositionType

  """
  Returns the last 3 days winrate for each hero by Difficulty in the Event Aghanim Labyrinth.
  """
  winRate(difficulty: AghanimLabMatchDifficultyEnum!): AghanimLabHeroWinRateType

  """Returns all the Abilities for a Hero on the Event Aghanim Labyrinth."""
  heroAbility(difficulty: AghanimLabMatchDifficultyEnum!): [AghanimLabHeroAbilityType]

  """
  Returns all the Room Types by Difficulty for the Event Aghanim Labyrinth.
  """
  room(difficulty: AghanimLabMatchDifficultyEnum!): [AghanimLabRoomType]

  """
  Returns all the Room Modifiers by Difficulty for the Event Aghanim Labyrinth.
  """
  roomModifier(difficulty: AghanimLabMatchDifficultyEnum!): [TI2020CustomGameRoomModifierType]
}

type AghanimLabMatchType {
  id: Long
  didWin: Boolean
  durationSeconds: Short
  startDateTime: Long
  endDateTime: Long
  clusterId: Short
  lobbyType: Byte
  numKills: Short
  numDeaths: Short
  numHumanPlayers: Byte
  gameMode: Byte
  replaySalt: Long
  difficulty: AghanimLabMatchDifficultyEnum
  depth: Byte
  seed: Int
  battlePoints: Short
  score: Int
  arcaneFragments: Short
  goldBags: Short
  regionId: Byte
  players(
    """
    The steam account id to include in this query, excluding all results that do not have this steam account id.
    """
    steamAccountId: Long
  ): [AghanimLabPlayerSeasonOneType]
  depthList: [AghanimLabMatchDepthListType]
}

enum AghanimLabMatchDifficultyEnum {
  APPRENTICE
  MAGICIAN
  SORCERER
  GRANDMAGUS
  APEXMAGE
}

type AghanimLabPlayerSeasonOneType {
  matchId: Long
  playerSlot: Byte
  steamAccountId: Long
  steamAccount: SteamAccountType
  isVictory: Boolean!
  heroId: Short
  hero: HeroType
  deaths: Long
  leaverStatus: Byte
  numLastHits: Short
  goldPerMinute: Short
  networth: Int
  experiencePerMinute: Short
  level: Byte
  goldSpent: Int
  partyId: Byte
  item0Id: Short
  item1Id: Short
  item2Id: Short
  item3Id: Short
  item4Id: Short
  item5Id: Short
  neutral0Id: Long
  arcaneFragments: Short
  bonusArcaneFragments: Short
  goldBags: Short
  neutralItemId: Short
  playerDepthList: [AghanimLabPlayerDepthListType]
  blessings: [AghanimLabPlayerBlessingObjectType]
}

type AghanimLabPlayerDepthListType {
  numDeaths: Short
  goldBags: Short
  kills: Short
  level: Byte
  networth: Int
  rarity: Byte
  selectedRewardAbilityId: Short
  selectedRewardAbility(
    """
    The language id to include in this query, excluding all results that do not have this language.
    """
    langaugeId: Int
  ): AbilityCustomGameType
  unSelectedRewardAbilityId1: Short
  unSelectedRewardAbility1(
    """
    The language id to include in this query, excluding all results that do not have this language.
    """
    langaugeId: Int
  ): AbilityCustomGameType
  unSelectedRewardAbilityId2: Short
  unSelectedRewardAbility2(
    """
    The language id to include in this query, excluding all results that do not have this language.
    """
    langaugeId: Int
  ): AbilityCustomGameType
  selectedRewardImageAbilityId: Short
}

type AbilityCustomGameType {
  id: Short
  name: String
  abilityName: String
  language: AbilityCustomGameLanguageType
}

type AbilityCustomGameLanguageType {
  displayName: String
  description: String
}

type AghanimLabPlayerBlessingObjectType {
  type: AghanimLabPlayerBlessingEnum
  value: Short
}

enum AghanimLabPlayerBlessingEnum {
  MODIFIER_BLESSING_AGILITY
  MODIFIER_BLESSING_ARMOR
  MODIFIER_BLESSING_ATTACK_SPEED
  MODIFIER_BLESSING_BASE
  MODIFIER_BLESSING_BOOK_AGILITY
  MODIFIER_BLESSING_BOOK_INTELLIGENCE
  MODIFIER_BLESSING_BOOK_STRENGTH
  MODIFIER_BLESSING_BOTTLE_UPGRADE
  MODIFIER_BLESSING_DAMAGE_BONUS
  MODIFIER_BLESSING_DAMAGE_REFLECT
  MODIFIER_BLESSING_DETONATION
  MODIFIER_BLESSING_EVASION
  MODIFIER_BLESSING_HEALTH_BOOST
  MODIFIER_BLESSING_INTELLIGENCE
  MODIFIER_BLESSING_LIFE_STEAL
  MODIFIER_BLESSING_MAGIC_DAMAGE_BONUS
  MODIFIER_BLESSING_MAGIC_RESIST
  MODIFIER_BLESSING_MANA_BOOST
  MODIFIER_BLESSING_MOVEMENT_SPEED
  MODIFIER_BLESSING_POTION_ARCANIST
  MODIFIER_BLESSING_POTION_DRAGON
  MODIFIER_BLESSING_POTION_ECHO_SLAM
  MODIFIER_BLESSING_POTION_HEALTH
  MODIFIER_BLESSING_POTION_MANA
  MODIFIER_BLESSING_POTION_PURIFICATION
  MODIFIER_BLESSING_POTION_RAVAGE
  MODIFIER_BLESSING_POTION_SHADOW_WAVE
  MODIFIER_BLESSING_POTION_TORRENT
  MODIFIER_BLESSING_REFRESHER_SHARD
  MODIFIER_BLESSING_RESPAWN_INVULNERABILITY
  MODIFIER_BLESSING_RESPAWN_TIME_REDUCTION
  MODIFIER_BLESSING_RESTORE_MANA
  MODIFIER_BLESSING_SPELL_LIFE_STEAL
  MODIFIER_BLESSING_STRENGTH
  BOTTLE_CHARGES
  STAT_AGI
  STAT_INT
  STAT_STR
  STAT_DAMAGE
  STAT_SPELL_AMP
  STAT_HEALTH
  STAT_MANA
  STAT_MAGIC_RESIST
  STARTING_GOLD
  PURIFICATION_POTION
  DEATH_DETONATION
  POTION_HEALTH
  POTION_MANA
  RESPAWN_TIME_REDUCTION
  BOTTLE_REGEN_DURATION
  BOTTLE_REGEN_MOVEMENT_SPEED
  ROSHAN_SHOP_DISCOUNT
  ORACLE_SHOP_DISCOUNT
  RESPAWN_INVULNERABILITY
  RESPAWN_HASTE
  RESPAWN_ATTACK_SPEED
  STAT_EVASION
  UPGRADE_REROLL
  ELITE_UPGRADE
  START_TOME
  BOSS_TOME
  EXTRA_LIFE
  MELEE_CLEAVE
  ATTACK_RANGE
  PROJECTILE_SPEED
  CAST_RANGE
  DAMAGE_ON_STUNNED
  REGEN_AROUND_ALLIES
  DEBUFF_DURATION_INCREASE
  LOW_HP_OUTGOING_DAMAGE
}

type AghanimLabMatchDepthListType {
  selectedElite: Boolean
  selectedEncounter: AghanimLabDepthListEncounterEnum
  selectedEncounterEnum: Byte
  selectedHidden: Boolean
  selectedReward: AghanimLabDepthListRewardEnum
  unselectedElite: Boolean
  unselectedEncounter: AghanimLabDepthListEncounterEnum
  unselectedHidden: Boolean
  unselectedReward: AghanimLabDepthListRewardEnum
  ascensionAbilities: [AghanimLabDepthListAscensionAbilitiesObjectType]
}

enum AghanimLabDepthListEncounterEnum {
  ENCOUNTER_EMPTY_CAVERN
  ENCOUNTER_EMPTY_BEACH
  ENCOUNTER_BREWMASTER
  ENCOUNTER_HELLBEARS_PORTAL_V_3
  ENCOUNTER_PINECONES
  ENCOUNTER_QUILL_BEASTS
  ENCOUNTER_JUNGLE_HIJINX
  ENCOUNTER_TUSK_SKELETONS
  ENCOUNTER_BOMBERS
  ENCOUNTER_DROW_RANGER_MINIBOSS
  ENCOUNTER_WAVE_BLASTERS
  ENCOUNTER_BABY_OGRES
  ENCOUNTER_MORPHLINGS_B
  ENCOUNTER_ZEALOT_SCARABS
  ENCOUNTER_OGRE_SEALS
  ENCOUNTER_WARLOCKS
  ENCOUNTER_GAUNTLET
  ENCOUNTER_MORTY_TRANSITION
  ENCOUNTER_PENGUINS_TRANSITION
  ENCOUNTER_MIRANA
  ENCOUNTER_MUSHROOM_MINES
  ENCOUNTER_LEGION_COMMANDER
  ENCOUNTER_TROLL_WARLORD
  ENCOUNTER_PUDGE_MINIBOSS
  ENCOUNTER_PUCKS
  ENCOUNTER_DARK_SEER
  ENCOUNTER_SPECTRES
  ENCOUNTER_SHADOW_DEMONS
  ENCOUNTER_NAGA_SIREN
  ENCOUNTER_DIRE_SIEGE
  ENCOUNTER_BIG_OGRES
  ENCOUNTER_DRAGON_KNIGHT
  ENCOUNTER_KUNKKA_TIDE
  ENCOUNTER_ALCHEMIST
  ENCOUNTER_ENRAGED_WILDWINGS
  ENCOUNTER_ELEMENTAL_TINY
  ENCOUNTER_BANDITS
  ENCOUNTER_BOMB_SQUAD
  ENCOUNTER_UNDEAD_WOODS
  ENCOUNTER_PHOENIX
  ENCOUNTER_BROODMOTHERS
  ENCOUNTER_FIRE_ROSHAN
  ENCOUNTER_BOSS_VISAGE
  ENCOUNTER_BOSS_TIMBERSAW
  ENCOUNTER_TEMPLE_GUARDIANS
  ENCOUNTER_STOREGGA
  ENCOUNTER_BOSS_VOID_SPIRIT
  ENCOUNTER_AGHANIM
  ENCOUNTER_JUNGLE_FIRE_MAZE
  ENCOUNTER_CLIFF_PASS
  ENCOUNTER_HELLFIRE_CANYON
  ENCOUNTER_TEMPLE_GARDEN
  ENCOUNTER_CASTLE_TRAPS
  ENCOUNTER_CRYPT_TRAPS
  ENCOUNTER_BONUS_CHICKEN
  ENCOUNTER_PANGOLIER
  ENCOUNTER_ROCK_GOLEMS
  ENCOUNTER_WENDIGOES
  ENCOUNTER_COLLAPSED_MINES
  ENCOUNTER_BEARS_LAIR
  ENCOUNTER_PINE_GROVE
  ENCOUNTER_SACRED_GROUNDS
  ENCOUNTER_DEEP_TRAPS
  ENCOUNTER_DARK_FOREST
  ENCOUNTER_TROPICAL_KEEP
  ENCOUNTER_SALTY_SHORE
  ENCOUNTER_REGAL_TRAPS
  ENCOUNTER_DESERT_OASIS
  ENCOUNTER_PRISON_TRAPS
  ENCOUNTER_BRIDGE_TRAPS
  ENCOUNTER_MOLE_CAVE
  ENCOUNTER_BLOB_DUNGEON
  ENCOUNTER_MULTIPLICITY
  ENCOUNTER_CATACOMBS
  ENCOUNTER_SWAMP_OF_SADNESS
  ENCOUNTER_CAVERN_TRAPS
  ENCOUNTER_AZIYOG_CAVERNS
  ENCOUNTER_BAMBOO_GARDEN
  ENCOUNTER_BOG_TRAPS
  ENCOUNTER_BOSS_WINTER_WYVERN
  ENCOUNTER_BOSS_EARTHSHAKER
  ENCOUNTER_BOSS_DARK_WILLOW
  ENCOUNTER_BOSS_RIZZRICK
  ENCOUNTER_PENGUIN_SLEDDING
  ENCOUNTER_BONUS_MANGO_ORCHARD
  ENCOUNTER_BONUS_HOOKING
  ENCOUNTER_MUSHROOM_MINES_2021
  ENCOUNTER_GAOLERS
  ENCOUNTER_EGGS_HOLDOUT
  ENCOUNTER_SPOOK_TOWN
  ENCOUNTER_TEMPLE_TRAPS
  ENCOUNTER_CANOPY_TRAPS
  ENCOUNTER_INNER_RING
  ENCOUNTER_LESHRAC
  ENCOUNTER_OUTWORLD
  ENCOUNTER_TWILIGHT_MAZE
  ENCOUNTER_RUINOUS_TRAPS
  ENCOUNTER_BEACH_TRAPS
  ENCOUNTER_GOLEM_GORGE
  ENCOUNTER_SNAPFIRE
  ENCOUNTER_POLARITY_SWAP
  ENCOUNTER_STONEHALL_CITADEL
  ENCOUNTER_MYSTICAL_TRAPS
  ENCOUNTER_HEDGE_TRAPS
  ENCOUNTER_TEMPLE_SIEGE
  ENCOUNTER_FORBIDDEN_PALACE
  ENCOUNTER_CRYPT_GATE
  ENCOUNTER_PUGNA_NETHER_REACHES
  ENCOUNTER_MINING_TRAPS
  ENCOUNTER_DUNGEON_TRAPS
  ENCOUNTER_BOSS_ARC_WARDEN
  ENCOUNTER_BOSS_CLOCKWERK_TINKER
  ENCOUNTER_BOSS_AMOEBA
  ENCOUNTER_BOSS_STOREGGA
  ENCOUNTER_BONUS_LIVESTOCK
  ENCOUNTER_BONUS_SMASH_CHICKENS
  ENCOUNTER_BONUS_GALLERY
  ENCOUNTER_TOXIC_TERRACE
  ENCOUNTER_HIDDEN_COLOSSEUM
  ENCOUNTER_FROZEN_RAVINE
  ENCOUNTER_PALACE_TRAPS
  ENCOUNTER_ICY_POOLS
  ENCOUNTER_DEMONIC_WOODS
  ENCOUNTER_THUNDER_MOUNTAIN
  ENCOUNTER_FRIGID_PINNACLE
  ENCOUNTER_VILLAGE_TRAPS
  ENCOUNTER_FORSAKEN_PIT
  ENCOUNTER_BURNING_MESA
  ENCOUNTER_SMASHY_AND_BASHY
  ENCOUNTER_PUSH_PULL
  ENCOUNTER_JUNGLE_TRAPS
  ENCOUNTER_TRANSITION_GATEWAY
  ENCOUNTER_PRIMAL_BEAST
  ENCOUNTER_EVENT_MINOR_SHARD_SHOP
  ENCOUNTER_EVENT_DOOM_LIFE_SWAP
  ENCOUNTER_EVENT_WARLOCK_LIBRARY
  ENCOUNTER_EVENT_ALCHEMIST_NEUTRAL_ITEMS
  ENCOUNTER_EVENT_BREWMASTER_BAR
  ENCOUNTER_EVENT_LIFE_SHOP
  ENCOUNTER_EVENT_MORPHLING_ATTRIBUTE_SHIFT
  ENCOUNTER_EVENT_TINKER_RANGE_RETROFIT
  ENCOUNTER_EVENT_NAGA_BOTTLE_RUNE
  ENCOUNTER_EVENT_SLARK
  ENCOUNTER_EVENT_ZEUS
  ENCOUNTER_EVENT_LESHRAC
  ENCOUNTER_EVENT_NECROPHOS
  ENCOUNTER_EVENT_SMALL_TINY_SHRINK
  ENCOUNTER_EVENT_BIG_TINY_GROW
  ENCOUNTER_EVENT_OGRE_MAGI_CASINO
  ENCOUNTER_SPLITSVILLE
  ENCOUNTER_AQUA_MANOR
  ENCOUNTER_JUNGLE_TREK
}

enum AghanimLabDepthListRewardEnum {
  REWARD_TYPE_NONE
  REWARD_TYPE_GOLD
  REWARD_TYPE_EXTRA_LIVES
  REWARD_TYPE_TREASURE
}

type AghanimLabDepthListAscensionAbilitiesObjectType {
  type: AghanimLabDepthListAscensionAbilitiesEnum
  abilityId: Short
  modifierId: Short
}

enum AghanimLabDepthListAscensionAbilitiesEnum {
  ASCENSION_ARMOR
  ASCENSION_ARMOR_SAPPING
  ASCENSION_ATTACK_SPEED
  ASCENSION_BOMB
  ASCENSION_CHILLING_TOUCH
  ASCENSION_CRIT
  ASCENSION_DAMAGE
  ASCENSION_DRUNKEN
  ASCENSION_EXTRA_FAST
  ASCENSION_FLICKER
  ASCENSION_HEAL_SUPPRESSION
  ASCENSION_MAGIC_IMMUNITY
  ASCENSION_MAGIC_RESIST
  ASCENSION_VAMPIRIC
  ASCENSION_MAGNETIC_FIELD
  ASCENSION_SILENCE
  ASCENSION_FIREFLY
  ASCENSION_EMBIGGEN
  ASCENSION_VENGEANCE
  AGHSFORT_ASCENSION_INVIS
  ASCENSION_METEORIC
  ASCENSION_PLASMA_FIELD
  ASCENSION_BULWARK
}

input FilterAghanimLabMatchRequestType {
  """Return Matches that only include the set of Match Ids provided."""
  matchIds: [Long]

  """Return matches that only include this single player."""
  steamAccountId: Long

  """Required that the team playing the game won."""
  didWin: Boolean

  """How far into the game (levels) they completed."""
  depth: Byte

  """The base level of difficulty"""
  difficulty: AghanimLabMatchDifficultyEnum

  """The team had to make it at least this far (level)."""
  minDepth: Byte

  """The max must be played in this list of regions"""
  regionIds: [Byte]

  """
  The game must of been played before this set time. In Unix Time Stamp Format.
  """
  createdBeforeDateTime: Long

  """
  The game must of been played after this set time. In Unix Time Stamp Format.
  """
  createdAfterDateTime: Long

  """The order in which the data returned will be sorted by."""
  orderBy: FilterAghanimLabMatchOrderBy

  """If the return should be ordered by Ascending or Desending order."""
  orderDirection: FilterOrder

  """
  The amount to have returned in your query. The maximum of this is always dynamic. Limit : 100
  """
  take: Int

  """
  The amount of data to skip before collecting your query. This is useful for Paging.
  """
  skip: Int

  """
  To date there are two seasons of Aghanim Labyrinth. Season 1 is the Year 2020 and Season 2 is 2021.
  """
  seasonId: Byte
}

enum FilterAghanimLabMatchOrderBy {
  DURATION
  END_DATE_TIME
}

enum FilterOrder {
  ASC
  DESC
}

type AghanimLabHeroCompositionType {
  difficulty: AghanimLabMatchDifficultyEnum
  heroId1: Short
  heroId2: Short
  heroId3: Short
  heroId4: Short
  matchCount: Int
  winCount: Int
  duration: Int
  wilsonScore: Decimal
}

input FilterAghanimLabHeroCompositionRequestType {
  """The base level of difficulty"""
  difficulty: AghanimLabMatchDifficultyEnum!

  """If the return should be ordered by Ascending or Desending order."""
  orderDirection: FilterOrder

  """
  The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
  """
  take: Int

  """
  The amount of data to skip before collecting your query. This is useful for Paging.
  """
  skip: Int
}

type AghanimLabHeroWinRateType {
  difficulty: AghanimLabMatchDifficultyEnum
  heroId: Short
  matchCount: Int
  winCount: Int
}

type AghanimLabHeroAbilityType {
  difficulty: AghanimLabMatchDifficultyEnum
  heroId: Short
  customAbilityId: Short
  matchCount: Int
  winCount: Int
  pickCount: Int
}

type AghanimLabRoomType {
  difficulty: AghanimLabMatchDifficultyEnum
  encounterId: AghanimLabDepthListEncounterEnum
  matchCount: Int
  winCount: Int
  pickCount: Int
  deathCount: Int
  eliteMatchCount: Int
  eliteWinCount: Int
  elitePickCount: Int
  eliteDeathCount: Int
}

type TI2020CustomGameRoomModifierType {
  difficulty: AghanimLabMatchDifficultyEnum
  modifierId: Short
  matchCount: Int
  winCount: Int
  deathCount: Int
  eliteMatchCount: Int
  eliteWinCount: Int
  eliteDeathCount: Int
}

type ImpQuery {
  """
  Returns details about all players in a specific match and details regarding Imp
  """
  matchGenerator(
    """
    The id of the Dota match to include in this query, excluding all results that do not include this id.
    """
    matchId: Long!
  ): ImpGeneratorMatchPlayerType

  """
  Returns details about a specific player in a game with certains events.
  """
  playerGenerator(request: ImpGeneratorRequestType!): ImpGeneratorPlayerType
}

type ImpGeneratorMatchPlayerType {
  winChance: [Float]
  winRateByPlayerMinuteValues: [[Float]]
  events: [[ImpGeneratorPlayerEventType]]
  impValues: [[Int]]
}

type ImpGeneratorPlayerEventType {
  time: Byte
  kills: UShort
  deaths: UShort
  assists: UShort
  cs: UShort
  dn: UShort
  level: Byte
  physicalDamage: Int
  magicalDamage: Int
  pureDamage: Int
  damageReceived: Int
  healingAllies: Int
  runePower: Int
  neutrals: Int
}

type ImpGeneratorPlayerType {
  winChance: [Float]
  winRateByPlayerMinuteValues: [[Float]]
  events: [ImpGeneratorPlayerEventType]
  impValues: [[Int]]
}

input ImpGeneratorRequestType {
  bans: [Short]!
  players: [ImpGeneratorPlayerRequestType]!
  isTurbo: Boolean!
}

input ImpGeneratorPlayerRequestType {
  heroId: Short!
  bracket: RankBracket!
  position: MatchPlayerPositionType!
  events: [ImpGeneratorPlayerEventRequestType]!
}

input ImpGeneratorPlayerEventRequestType {
  time: Byte!
  kills: UShort!
  deaths: UShort!
  assists: UShort!
  cs: UShort!
  dn: UShort!
  level: Byte!
  physicalDamage: Int!
  magicalDamage: Int!
  pureDamage: Int!
  damageReceived: Int!
  healingAllies: Int!
  runePower: Int!
  neutrals: Int!
}

type PageDireTideQuery {
  """Returns a match by Id based on the Halloween Event DireTide."""
  match(
    """
    The id of the Dota match to include in this query, excluding all results that do not include this id.
    """
    id: Long!
  ): DireTideCustomGameMatchType

  """Returns a list of matches by based on the Halloween Event DireTide."""
  matches(request: FilterDireTideCustomMatchRequestType!): [DireTideCustomGameMatchType]

  """
  Returns the last 12 days by day showing the amount of matches and the amount of wins by hero id.
  """
  winDay(
    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int
  ): [DireTideCustomGameHeroWinDayType]
}

type DireTideCustomGameMatchType {
  id: Long
  didRadiantWin: Boolean
  durationSeconds: Short
  startDateTime: Long
  endDateTime: Long
  clusterId: Short
  replaySalt: Long
  candyLost: Short
  candyPickedUp: Short
  candyScored: Short
  radiantCandyScored: Short
  direCandyScored: Short
  players(
    """
    The steam account id to include in this query, excluding all results that do not have this steam account id.
    """
    steamAccountId: Long
  ): [DireTideCustomGamePlayerType]
}

type DireTideCustomGamePlayerType {
  matchId: Long
  playerSlot: Byte
  steamAccountId: Long
  steamAccount: SteamAccountType
  isVictory: Boolean!
  heroId: Short
  hero: HeroType
  kills: Byte
  deaths: Byte
  assists: Byte
  leaverStatus: Byte
  numLastHits: Short
  goldPerMinute: Short
  goldSpent: Int
  level: Byte
  heroDamage: Int
  heroHealing: Int
  networth: Int
  item0Id: Short
  item1Id: Short
  item2Id: Short
  item3Id: Short
  item4Id: Short
  item5Id: Short
  backpack0Id: Short
  backpack1Id: Short
  backpack2Id: Short

  """
  The item id of the dedicated neutral item slot (7.24 and after). From game versions 7.23 to 7.24, this was the BackPack3Id (the 4th backpack slot item id).
  """
  neutral0Id: Short
  partyId: Byte
  candyLost: Short
  candyPickedUp: Short
  candyScored: Short
}

input FilterDireTideCustomMatchRequestType {
  """
  The steam account id to include in this query, excluding all results that do not have this steam account id.
  """
  steamAccountId: Long

  """The order in which the data returned will be sorted by."""
  orderBy: FilterDireTide2020CustomGameMatchOrderBy

  """If the return should be ordered by Ascending or Desending order."""
  orderDirection: FilterOrder

  """
  The amount to have returned in your query. The maximum of this is always dynamic. Limit : 20
  """
  take: Int

  """
  The amount of data to skip before collecting your query. This is useful for Paging.
  """
  skip: Int
}

enum FilterDireTide2020CustomGameMatchOrderBy {
  CANDY_SCORED
  END_DATE_TIME
}

type DireTideCustomGameHeroWinDayType {
  day: Long!
  heroId: Short!
  winCount: Int!
  matchCount: Int!
  candyScored: Int!
}

type PageBattlepassQuery {
  predictionsHero(
    """
    An array of league ids to include in this query, excluding all results that do not include one of these leagues.
    """
    leagueIds: [Int]!
  ): [BattlepassPredictionHeroType]
  predictionsTeams(
    """
    An array of team ids to include in this query, excluding all results that do not have this team id.
    """
    teamIds: [Int]!

    """
    An array of league ids to include in this query, excluding all results that do not include one of these leagues.
    """
    leagueIds: [Int]!

    """
    This will alter the team data to take the average of the matches if true. If false, it will find the top instance for each category (1).
    """
    averaged: Boolean
  ): [BattlepassPredictionTeamType]
  predictionsPlayers(
    """
    An array of team ids to include in this query, excluding all results that do not have this team id.
    """
    teamIds: [Int]!

    """
    An array of league ids to include in this query, excluding all results that do not include one of these leagues.
    """
    leagueIds: [Int]!
  ): [BattlepassPredictionPlayerType]
  predictionsTournament(
    """
    An array of team ids to include in this query, excluding all results that do not have this team id.
    """
    teamIds: [Int]!

    """
    An array of league ids to include in this query, excluding all results that do not include one of these leagues.
    """
    leagueIds: [Int]!
  ): BattlepassPredictionTournamentType
}

type BattlepassPredictionHeroType {
  heroId: Short
  hero: HeroType
  matchCount: Int
  matchCountBanned: Int
  winRate: Float
  killAvg: Float
  assistAvg: Float
  deathAvg: Float
  lastHitAvg: Float
  experiencePerMinuteAvg: Float
  mostKills: Int
  mostDeaths: Int
  mostAssists: Int
  mostLastHits: Int
}

type BattlepassPredictionTeamType {
  teamId: Int
  team: TeamType
  matchCount: Int
  mostKills: Float
  killAvg: Float
  leastDeaths: Float
  mostAssists: Float
  longestGameSeconds: Int
  shortestGameSeconds: Int
  gameSecondsAvg: Float
  heroCount: Int
}

type BattlepassPredictionPlayerType {
  steamAccountId: Int
  steamAccount: SteamAccountType
  matchCount: Int
  killAvg: Float
  mostKills: Int
  deathAvg: Float
  assistAvg: Float
  mostAssists: Int
  lastHitAvg: Float
  mostLastHits: Int
  mostGoldPerMinute: Int
  goldPerMinuteAvg: Int
  heroCount: Int
}

type BattlepassPredictionTournamentType {
  heroesPicked: [BattlepassPredictionIdValueType]
  heroesBanned: [BattlepassPredictionIdValueType]
  totalKills: [BattlepassPredictionIdValueType]
  longestGame: [BattlepassPredictionIdValueType]
  soloKills: [BattlepassPredictionIdValueType]
  soloDeaths: [BattlepassPredictionIdValueType]
  soloAssists: [BattlepassPredictionIdValueType]
  soloGoldPerMinute: [BattlepassPredictionIdValueType]
}

type BattlepassPredictionIdValueType {
  id: Long
  matchCount: Int
}

type NewsItemType {
  id: Long
  title: String!
  uri: String!
  author: String!
  contents: String!
  feedLabel: String!
  date: Long
  feedName: String!
}

type ServerStatusType {
  isRedisOnline: Boolean!
  steamApiDetail: SteamApiDetailType
  rabbitDetail: RabbitDetailType
}

type SteamApiDetailType {
  isOnline: Boolean!
  outages: [SteamApiDetailOutageType]
}

type SteamApiDetailOutageType {
  secondsOffline: Int
  dateTime: Long
}

type RabbitDetailType {
  lastUpdated: Long
  isOnline: Boolean!
  matchHistory: RabbitQueueDetailType
  matchDetail: RabbitQueueDetailType
  matchDetailDelay: RabbitQueueDetailType
  matchStats: RabbitQueueDetailType
  steamAccount: RabbitQueueDetailType
  matchLive: RabbitQueueDetailType
}

type RabbitQueueDetailType {
  queueCount: Int!
  queueInRate: Decimal
  queueOutRate: Decimal
}

type LanguageType {
  id: Byte!
  languageCode: String
  displaLanguageNameyName: String
}

type SearchType {
  players: [SteamAccountType]
  matches: [MatchType]
  leagues: [LeagueType]
  teams: [TeamType]
  proPlayers: [SteamAccountType]
  casters: [SteamAccountType]
  guild: GuildType
  direTideMatches: [DireTideCustomGameMatchType]
}

input FilterSearchRequestType {
  """
  The term used to define the search parameters. Minimum input is 2 characters.
  """
  query: String!

  """
  Searching our entire database can take time. If you already know what your searching for you, you can limit the query down to a set of specific types. (0 - Playuers, 1 - Matches, 2 - Leagues, 3 - Teams, 4 - ProPlayers, 5 - Casters). Default is all types.
  """
  searchType: [Search]

  """
  The minimum rank a player must have to be allowed inside the search query.
  """
  minimumRank: Int

  """
  The maximum rank a player must have to be allowed inside the search query.
  """
  maximumRank: Int

  """
  The minimum amount of time in which a user must have played a game to be allowed inside the search query. A unix timestamp.
  """
  lastMatchPlayedAgo: Long

  """
  The leaderboard is split into 4 regions. The user must appear in this region(s) for them to be allowed inside the search query.
  """
  leaderboardRegionIds: [Byte]

  """
  When searching for a league, the tier the league must be in. Tiers: Amateur = 1, Professional = 2, Premium = 3, Pro Circuit = 4, Main Event = 5
  """
  leagueTierIds: [LeagueTier]

  """
  When searching for a team, only return results of those teams of which are considered Professionals.
  """
  teamIsPro: Boolean

  """
  The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
  """
  take: Int
}

enum Search {
  PLAYERS
  MATCHES
  LEAGUES
  TEAMS
  PRO_PLAYERS
  CASTERS
  GUILDS
}

type HeroStatsQuery {
  """Detailed output of data per minute for each hero."""
  stats(
    """
    An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
    """
    heroIds: [Short]

    """
    The week to include in this query, excluding all results that do not include this week. The value is an epoc TimeStamp of the week of data you want. Leaving null gives the current week.
    """
    week: Long

    """
    An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketBasicIds: [RankBracketBasicEnum]

    """
    An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes.
    """
    positionIds: [MatchPlayerPositionType]
    groupByTime: Boolean
    groupByPosition: Boolean
    groupByBracket: Boolean

    """
    Integer in minutes which determines the start of the data. For example, 10 would result in every event after 10:00 mark in-game. Minimum input value is 0.
    """
    minTime: Int

    """
    Integer in minutes which determines the start of the data. For example, 10 would result in every event before 10:00 mark in-game Maximum input value is 75.
    """
    maxTime: Int
  ): [HeroPositionTimeDetailType]

  """
  Returns back a list of the hero matchups, showing how that hero's win rate is affected with or against other heroes.
  """
  matchUp(
    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short

    """
    The week to include in this query, excluding all results that do not include this week. The value is an epoc TimeStamp of the week of data you want. Leaving null gives the current week.
    """
    week: Long

    """
    An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketBasicIds: [RankBracketBasicEnum]

    """
    Id representing how to order dryads and triads. Synergy is STRATZ formula to help determine the best outcome of wins and picks in one. Accepted Inputs : Synergy = 0, Pick = 1, Win = 2, Loss = 3, Disadvantage = 4, Advantage = 5
    """
    orderBy: Byte

    """Minimum amount of MatchCount required for a Duo to qualify"""
    matchLimit: Int

    """
    The amount of data to skip before collecting your query. This is useful for Paging.
    """
    skip: Int

    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int
  ): [HeroDryadType]

  """
  Returns the items purchased for the selected hero. Adjusting the time adjusts the purchase amount. Shows win rate by item timings.
  """
  itemFullPurchase(
    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short!

    """
    The week to include in this query, excluding all results that do not include this week. The value is an epoc TimeStamp of the week of data you want. Leaving null gives the current week.
    """
    week: Long

    """
    An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketBasicIds: [RankBracketBasicEnum]

    """
    An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes.
    """
    positionIds: [MatchPlayerPositionType]

    """
    Integer in minutes which determines the start of the data. For example, 10 would result in every event after 10:00 mark in-game. Minimum input value is 0.
    """
    minTime: Int

    """
    Integer in minutes which determines the start of the data. For example, 10 would result in every event before 10:00 mark in-game Maximum input value is 75.
    """
    maxTime: Int

    """Minimum amount of MatchCount required for a Duo to qualify"""
    matchLimit: Int
  ): [HeroItemPurchaseType]

  """
  This snapshots all items in the inventory of a hero at -00:30.   It tracks if an item was given or purchased.
  """
  itemStartingPurchase(
    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short!

    """
    The week to include in this query, excluding all results that do not include this week. The value is an epoc TimeStamp of the week of data you want. Leaving null gives the current week.
    """
    week: Long

    """
    An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketBasicIds: [RankBracketBasicEnum]

    """
    An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes.
    """
    positionIds: [MatchPlayerPositionType]
  ): [HeroItemStartingPurchaseType]

  """
  The purchase Item Components for a Hero's Boots.  Tracks things like activations or uses throughout the game.
  """
  itemBootPurchase(
    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short!

    """
    The week to include in this query, excluding all results that do not include this week. The value is an epoc TimeStamp of the week of data you want. Leaving null gives the current week.
    """
    week: Long

    """
    An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketBasicIds: [RankBracketBasicEnum]

    """
    An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes.
    """
    positionIds: [MatchPlayerPositionType]
  ): [HeroItemBootPurchaseType]

  """The amount of times a Nutreal Item was found and won."""
  itemNeutral(
    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short!

    """
    The week to include in this query, excluding all results that do not include this week. The value is an epoc TimeStamp of the week of data you want. Leaving null gives the current week.
    """
    week: Long

    """
    An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketBasicIds: [RankBracketBasicEnum]

    """
    An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes.
    """
    positionIds: [MatchPlayerPositionType]
  ): [HeroNeutralItemType]

  """
  Using out formula for determining the outcome of lane, the overall success of that hero in that role.
  """
  laneOutcome(
    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short!

    """
    The lane outcomes are split into with heroes and against. Send false if you want lane matchups against the heroid. Send true if you want friendly.
    """
    isWith: Boolean!

    """
    The week to include in this query, excluding all results that do not include this week. The value is an epoc TimeStamp of the week of data you want. Leaving null gives the current week.
    """
    week: Long

    """
    An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketBasicIds: [RankBracketBasicEnum]

    """
    An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes.
    """
    positionIds: [MatchPlayerPositionType]
  ): [HeroLaneOutcomeType]

  """
  This is used on the Hero page to show the comparison of skill with the selected hero with other heroes.  It includes our Synergy and our Advantage formulas to ensure that a hero with a high win rate isn't simply just on the top of all the fields.
  """
  heroVsHeroMatchup(
    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short!

    """
    The week to include in this query, excluding all results that do not include this week. The value is an epoc TimeStamp of the week of data you want. Leaving null gives the current week.
    """
    week: Long

    """
    An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketBasicIds: [RankBracketBasicEnum]

    """Minimum amount of MatchCount required for a Duo to qualify"""
    matchLimit: Int

    """
    The amount of data to skip before collecting your query. This is useful for Paging.
    """
    skip: Int

    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int
  ): HeroMatchupType

  """
  This is used on the Hero page to show the comparison of all Hero Talents with the selected hero.
  """
  talent(
    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short!

    """
    The week to include in this query, excluding all results that do not include this week. The value is an epoc TimeStamp of the week of data you want. Leaving null gives the current week.
    """
    week: Long

    """
    An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketBasicIds: [RankBracketBasicEnum]

    """
    An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes.
    """
    positionIds: [MatchPlayerPositionType]
  ): [HeroAbilityTalentType]

  """
  Returns the last 12 hours by hour showing the amount of matches and the amount of wins by hero id.
  """
  winHour(
    """
    An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
    """
    heroIds: [Short]

    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int

    """
    An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketIds: [RankBracket]

    """
    An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes.
    """
    positionIds: [MatchPlayerPositionType]

    """
    An array of region ids to include in this query, excluding all results that do not include one of these regions.
    """
    regionIds: [BasicRegionType]

    """
    An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
    """
    gameModeIds: [GameModeEnumType]

    """
    Only used when doing matchesGroupBy endpoint.  This is how the data will be grouped and makes your return Id field.
    """
    groupBy: FilterHeroWinRequestGroupBy
  ): [HeroWinHourType]

  """
  Returns the last 12 days by day showing the amount of matches and the amount of wins by hero id.
  """
  winDay(
    """
    An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
    """
    heroIds: [Short]

    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int

    """
    An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketIds: [RankBracket]

    """
    An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes.
    """
    positionIds: [MatchPlayerPositionType]

    """
    An array of region ids to include in this query, excluding all results that do not include one of these regions.
    """
    regionIds: [BasicRegionType]

    """
    An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
    """
    gameModeIds: [GameModeEnumType]

    """
    Only used when doing matchesGroupBy endpoint.  This is how the data will be grouped and makes your return Id field.
    """
    groupBy: FilterHeroWinRequestGroupBy
  ): [HeroWinDayType]

  """
  Returns the last 12 weeks by week showing the amount of matches and the amount of wins by hero id.
  """
  winWeek(
    """
    An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
    """
    heroIds: [Short]

    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int

    """
    An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketIds: [RankBracket]

    """
    An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes.
    """
    positionIds: [MatchPlayerPositionType]

    """
    An array of region ids to include in this query, excluding all results that do not include one of these regions.
    """
    regionIds: [BasicRegionType]

    """
    An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
    """
    gameModeIds: [GameModeEnumType]

    """
    Only used when doing matchesGroupBy endpoint.  This is how the data will be grouped and makes your return Id field.
    """
    groupBy: FilterHeroWinRequestGroupBy
  ): [HeroWinWeekType]

  """
  Returns the data by month showing the amount of matches and the amount of wins by hero id.
  """
  winMonth(
    """
    An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
    """
    heroIds: [Short]

    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int

    """
    The amount of data to skip before collecting your query. This is useful for Paging.
    """
    skip: Int

    """
    An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketIds: [RankBracket]

    """
    An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes.
    """
    positionIds: [MatchPlayerPositionType]

    """
    An array of region ids to include in this query, excluding all results that do not include one of these regions.
    """
    regionIds: [BasicRegionType]

    """
    An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
    """
    gameModeIds: [GameModeEnumType]

    """
    Only used when doing matchesGroupBy endpoint.  This is how the data will be grouped and makes your return Id field.
    """
    groupBy: FilterHeroWinRequestGroupBy
  ): [HeroWinMonthType]

  """
  Returns the data by game version showing the amount of matches and the amount of wins by hero id.
  """
  winGameVersion(
    """
    An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
    """
    heroIds: [Short]

    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int

    """
    The amount of data to skip before collecting your query. This is useful for Paging.
    """
    skip: Int

    """
    An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketIds: [RankBracket]

    """
    An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes.
    """
    positionIds: [MatchPlayerPositionType]

    """
    An array of region ids to include in this query, excluding all results that do not include one of these regions.
    """
    regionIds: [BasicRegionType]

    """
    An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
    """
    gameModeIds: [GameModeEnumType]

    """
    Only used when doing matchesGroupBy endpoint.  This is how the data will be grouped and makes your return Id field.
    """
    groupBy: FilterHeroWinRequestGroupBy
  ): [HeroWinGameVersionType]
  guide(
    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short

    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    withHeroId: Short

    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    againstHeroId: Short

    """
    Determines that the query require the results come with a player that is qualified as a Pro.
    """
    isPro: Boolean

    """
    An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes.
    """
    positionId: MatchPlayerPositionType

    """
    The item id to include in this query, excluding all results that do not have this item.
    """
    itemId: Short

    """
    The item id of the dedicated neutral item slot (7.24 and after). From game versions 7.23 to 7.24, this was the BackPack3Id (the 4th backpack slot item id).
    """
    neutralItemId: Short

    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int

    """
    The amount of data to skip before collecting your query. This is useful for Paging.
    """
    skip: Int
  ): [HeroGuideListType]
  rampages(request: FilterHeroRampageType!): [HeroRampageObjectType]

  """This helps determine at what level do you max a skill."""
  abilityMinLevel(
    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short!

    """
    The week to include in this query, excluding all results that do not include this week. The value is an epoc TimeStamp of the week of data you want. Leaving null gives the current week.
    """
    week: Long

    """
    An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketBasicIds: [RankBracketBasicEnum]

    """
    An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes.
    """
    positionIds: [MatchPlayerPositionType]
  ): [HeroAbilityMinType]

  """This helps determine at what level you first level a skill. (Level 1)"""
  abilityMaxLevel(
    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short!

    """
    The week to include in this query, excluding all results that do not include this week. The value is an epoc TimeStamp of the week of data you want. Leaving null gives the current week.
    """
    week: Long

    """
    An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketBasicIds: [RankBracketBasicEnum]

    """
    An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes.
    """
    positionIds: [MatchPlayerPositionType]
  ): [HeroAbilityMaxType]

  """
  This data for each day where a Hero is actually banned. This does not include data in which a hero was nominated for a ban but didn't actual get banned. Only data where a player actually requests a ban and its banned is shown.
  """
  banDay(
    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short!

    """
    The day to include in this query, excluding all results that do not include this day. The value is an epoc TimeStamp of the day of data you want. Leaving null gives the current day.
    """
    day: Int

    """
    An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketBasicIds: [RankBracketBasicEnum]

    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int

    """
    The amount of data to skip before collecting your query. This is useful for Paging.
    """
    skip: Int

    """
    Only used when doing matchesGroupBy endpoint.  This is how the data will be grouped and makes your return Id field.
    """
    groupByDay: Boolean

    """
    Only used when doing matchesGroupBy endpoint.  This is how the data will be grouped and makes your return Id field.
    """
    groupByRank: Boolean
  ): [HeroBanType]
}

type HeroDryadType {
  heroId: Short
  with: [HeroStatsHeroDryadType]
  matchCountWith: Long
  vs: [HeroStatsHeroDryadType]
  matchCountVs: Long
}

type HeroStatsHeroDryadType {
  heroId1: Short
  heroId2: Short
  week: Int
  bracketBasicIds: RankBracketBasicEnum
  kills: Long
  matchCount: Long
  deaths: Long
  assists: Long
  networth: Long
  duration: Long
  winCount: Long
  firstBloodTime: Long
  cs: Long
  dn: Long
  goldEarned: Long
  xp: Long
  heroDamage: Long
  towerDamage: Long
  heroHealing: Long
  level: Long
  synergy: Decimal
  winRateHeroId1: Decimal
  winRateHeroId2: Decimal
  winsAverage: Decimal
}

type HeroItemPurchaseType {
  heroId: Int!
  week: Int!
  bracketBasicIds: RankBracketBasicEnum
  position: MatchPlayerPositionType
  itemId: Int!
  instance: Int!
  time: Long
  matchCount: Long
  winCount: Long
  winsAverage: Decimal
}

type HeroItemStartingPurchaseType {
  heroId: Int!
  week: Int!
  bracketBasicIds: RankBracketBasicEnum
  position: MatchPlayerPositionType
  itemId: Int!
  instance: Int!
  wasGiven: Boolean!
  matchCount: Long
  winCount: Long
  winsAverage: Decimal
}

type HeroItemBootPurchaseType {
  heroId: Int!
  week: Int!
  bracketBasicIds: RankBracketBasicEnum
  position: MatchPlayerPositionType
  itemId: Int!
  instance: Int!
  time: Long
  timeAverage: Decimal
  matchCount: Long
  winCount: Long
  winAverage: Decimal
  kills: Long
  killsAverage: Decimal
  deaths: Long
  deathsAverage: Decimal
  assists: Long
  assistsAverage: Decimal
  goldEarned: Long
  goldEarnedAverage: Decimal
  xp: Long
  xpAverage: Decimal
  activations: Long
  activationsAverage: Decimal
  activationTime: Long
  activationsTimeAverage: Decimal
}

type HeroNeutralItemType {
  heroId: Int!
  week: Int!
  bracketBasicIds: RankBracketBasicEnum
  position: MatchPlayerPositionType
  itemId: Int
  matchCount: Long
  winCount: Long
  equippedMatchCount: Long
  equippedMatchWinCount: Long
}

type HeroLaneOutcomeType {
  heroId1: Int!
  week: Int!
  bracketBasicIds: RankBracketBasicEnum
  position: MatchPlayerPositionType
  matchCount: Long
  drawCount: Long
  winCount: Long
  lossCount: Long
  stompWinCount: Long
  stompLossCount: Long
  heroId2: Short!
}

type HeroMatchupType {
  advantage: [HeroDryadType]
  disadvantage: [HeroDryadType]
}

type HeroAbilityTalentType {
  heroId: Int!
  week: Int!
  bracketBasicIds: RankBracketBasicEnum
  position: MatchPlayerPositionType
  abilityId: Int!
  matchCount: Long!
  winCount: Long!
  time: Long
  winsAverage: Decimal
  timeAverage: Decimal
}

type HeroWinHourType {
  hour: Long!
  heroId: Short!
  winCount: Int!
  matchCount: Int!
}

enum FilterHeroWinRequestGroupBy {
  HERO_ID
  ALL
  HERO_ID_DURATION_MINUTES
  TIME
}

type HeroWinDayType {
  day: Long!
  heroId: Short!
  winCount: Int!
  matchCount: Int!
}

type HeroWinWeekType {
  week: Long!
  heroId: Short!
  durationMinute: Byte!
  winCount: Int!
  matchCount: Int!
}

type HeroWinMonthType {
  month: Long!
  heroId: Short!
  durationMinute: Byte!
  winCount: Int!
  matchCount: Int!
}

type HeroWinGameVersionType {
  gameVersionId: Short!
  heroId: Short!
  durationMinute: Byte!
  winCount: Int!
  matchCount: Int!
}

type HeroGuideListType {
  heroId: Short
  matchCount: Int

  """Guides are auto-generated of games that are successful in a game."""
  guides(
    """
    The item id to include in this query, excluding all results that do not have this item.
    """
    itemId: Short

    """
    The item id of the dedicated neutral item slot (7.24 and after). From game versions 7.23 to 7.24, this was the BackPack3Id (the 4th backpack slot item id).
    """
    neutralItemId: Short

    """
    The amount of data to skip before collecting your query. This is useful for Paging.
    """
    skip: Int

    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int
  ): [HeroGuideType]
}

type HeroGuideType {
  heroId: Short
  steamAccountId: Long
  matchId: Long
  match: MatchType
  matchPlayer: MatchPlayerType
  createdDateTime: Long
  itemIds: [Short]
  neutralItemIds: [Short]
}

type HeroRampageObjectType {
  matchId: Long
  match: MatchType
  time: Short!
  steamAccountId: Long
  heroIds: [Short]
  steamAccount: SteamAccountType
}

input FilterHeroRampageType {
  """
  The hero id to include in this query, excluding all results that do not include this hero.
  """
  heroId: Short

  """
  An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
  """
  bracketBasicIds: [RankBracketBasicEnum]

  """
  The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
  """
  take: Int!

  """Only return matches after this match id. Can be used instead of Skip."""
  after: Long

  """Only return matches before this match id. Can be used instead of Skip."""
  before: Long
}

type HeroAbilityMinType {
  heroId: Int!
  week: Int!
  bracketBasicIds: RankBracketBasicEnum
  position: MatchPlayerPositionType
  abilityId: Int
  level: Int
  matchCount: Long
  winCount: Long
}

type HeroAbilityMaxType {
  heroId: Int!
  week: Int!
  bracketBasicIds: RankBracketBasicEnum
  position: MatchPlayerPositionType
  abilityId: Int
  level: Int
  matchCount: Long
  winCount: Long
}

type HeroBanType {
  heroId: Short
  day: Int
  bracketBasicIds: RankBracketBasicEnum
  matchCount: Long
  winCount: Long
}

type ConstantQuery {
  hero(
    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    id: Short!

    """
    The game version id to include in this query, excluding all results that do not have this game version.
    """
    gameVersionId: Short

    """
    The language id to include in this query, excluding all results that do not have this language.
    """
    language: Language
  ): HeroType
  heroes(
    """
    The game version id to include in this query, excluding all results that do not have this game version.
    """
    gameVersionId: Short

    """
    The language id to include in this query, excluding all results that do not have this language.
    """
    language: Language
  ): [HeroType]

  """List of all the roles types for heroes."""
  roles: [RoleType]

  """Find item details by item id. id is a required input field."""
  item(
    """
    The item id to include in this query, excluding all results that do not have this item.
    """
    id: Int!

    """
    The game version id to include in this query, excluding all results that do not have this game version.
    """
    gameVersionId: Short

    """
    The language id to include in this query, excluding all results that do not have this language.
    """
    language: Language
  ): ItemType

  """Find item details by item id. id is a required input field."""
  items(
    """
    The game version id to include in this query, excluding all results that do not have this game version.
    """
    gameVersionId: Short

    """
    The language id to include in this query, excluding all results that do not have this language.
    """
    language: Language
  ): [ItemType]

  """Find ability details by ability id. id is a required input field."""
  ability(
    """
    The ability id to include in this query, excluding all results that do not have this ability.
    """
    id: Int!

    """
    The game version id to include in this query, excluding all results that do not have this game version.
    """
    gameVersionId: Short

    """
    The language id to include in this query, excluding all results that do not have this language.
    """
    language: Language
  ): AbilityType

  """Find ability details."""
  abilities(
    """
    The game version id to include in this query, excluding all results that do not have this game version.
    """
    gameVersionId: Short

    """
    The language id to include in this query, excluding all results that do not have this language.
    """
    language: Language
  ): [AbilityType]

  """
  Returns a list of game mode types which is directly supplied by Dota 2. Matches API call will have a input for this value.
  """
  gameModes: [GameModeType]

  """
  Returns a list of lobby types which are mirrored from the Dota 2 client.
  """
  lobbyTypes: [LobbyTypeType]

  """
  Provided directly from Dota 2 Region files, the cluster is the geographically breakdown of where the game is played.
  """
  clusters: [ClusterType]

  """Returns a list of region details and an Id for reference."""
  regions: [RegionType]

  """
  Find game version details by game version id. id is a required input field.
  """
  gameVersion(
    """
    The game version id to include in this query, excluding all results that do not have this game version.
    """
    id: Short!
  ): GameVersionType

  """Find game version details."""
  gameVersions: [GameVersionType]

  """Find npc details by npc id. id is a required input field."""
  npc(
    """
    The npc id to include in this query, excluding all results that do not have this npc.
    """
    id: Short!

    """
    The game version id to include in this query, excluding all results that do not have this game version.
    """
    gameVersionId: Short
  ): NpcType

  """Find npc details."""
  npcs(
    """
    The game version id to include in this query, excluding all results that do not have this game version.
    """
    gameVersionId: Short
  ): [NpcType]

  """
  Find all patch notes for each item and ability. These are found when you hover over each object in-game.
  """
  patchNotes(
    """
    The language id to include in this query, excluding all results that do not have this language.
    """
    languageId: Language
  ): [PatchNoteLanguageType]

  """
  Find all abilities that are used in custom events. For example Aghnims Labyrinth.
  """
  customAbilities(
    """
    The language id to include in this query, excluding all results that do not have this language.
    """
    languageId: Language
  ): [AbilityCustomGameType]

  """
  Find all modifiers that are used in the game. If you find a bug on a modifier, let us know as we have to control this ourselves.
  """
  modifiers(
    """
    The amount of data to skip before collecting your query. This is useful for Paging.
    """
    skip: Int

    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int
  ): [ModifierType]

  """Find all players who Valve qualifies as a Pro Player or Streamer."""
  proSteamAccounts: [ProSteamAccountType]
  popularTeamIds: [TeamType]
  casters: [SteamAccountType]
  tiWinners: [SteamAccountType]
}

type RoleType {
  roleId: Short
  name: String
  langKey: String
}

type ItemType {
  id: Short
  name: String
  displayName: String
  shortName: String
  isSupportFullItem: Boolean
  language: ItemLanguageType
  stat: ItemStatType
  attributes: [ItemAttributeType]
  components: [ItemComponentType]
  image: String
}

type ItemLanguageType {
  displayName: String
  description: [String]
  lore: [String]
  notes: [String]
  attributes: [String]
}

type ItemStatType {
  behavior: Long
  unitTargetType: Long
  unitTargetTeam: Long
  unitTargetFlags: Long
  fightRecapLevel: Byte
  castRange: [Int]
  castPoint: [Float]
  manaCost: [Float]
  channelTime: [Float]
  sharedCooldown: String
  cost: Int
  shopTags: String
  aliases: String
  quality: String
  isSellable: Boolean
  isDroppable: Boolean
  isPurchasable: Boolean
  isSideShop: Boolean
  isStackable: Boolean
  isPermanent: Boolean
  isHideCharges: Boolean
  isRequiresCharges: Boolean
  isDisplayCharges: Boolean
  isSupport: Boolean
  isAlertable: Boolean
  isTempestDoubleClonable: Boolean
  stockMax: Short
  initialCharges: Short
  initialStock: Short
  stockTime: Int
  initialStockTime: Short
  isRecipe: Boolean
  needsComponents: Boolean
  upgradeItem: Short
  upgradeRecipe: Short
  itemResult: Short
  neutralItemDropTime: Short
  neutralItemTier: NeutralItemTierEnum
}

enum NeutralItemTierEnum {
  TIER_1
  TIER_2
  TIER_3
  TIER_4
  TIER_5
}

type ItemAttributeType {
  name: String
  value: String
}

type ItemComponentType {
  index: Byte
  componentId: Short
}

type GameModeType {
  id: Short
  name: String
}

type LobbyTypeType {
  id: Int!
  name: String
}

type ClusterType {
  """
  ClusterId which determines in which region a match was played. One region has multiple clusters. When selecting your region in the Dota 2 client, a random cluster is provided to you for each match for load balancing purposes.
  """
  id: Int

  """RegionId gives the exact geographical area where the match is played."""
  regionId: Short
}

type RegionType {
  id: Byte
  name: String
  clientName: String
  displayName: String
  leaderboardDivision: String
  langKey: String
  latitude: Decimal
  longitude: Decimal
  code: String
  matchGroup: Byte
  weekendTourneyDivision: String
}

type GameVersionType {
  id: Short
  name: String
  asOfDateTime: Long
}

type NpcType {
  id: Short
  name: String
  stat: NpcStatType
}

type NpcStatType {
  level: Float
  statusHealth: Float
  statusHealthRegen: Float
  statusMana: Float
  statusManaRegen: Float
  movementSpeed: Float
  movementTurnRate: Float
  dayTimeVision: Float
  nightTimeVision: Float
  attackRangeBuffer: Float
  attackRange: Float
  isNeutralUnitType: Boolean
  isAncient: Boolean
  canBeDominated: Boolean
  autoAttacksByDefault: Boolean
  attackDamageMin: Float
  attackDamageMax: Float
  attackRate: Float
  attackAnimationPoint: Float
  projectileSpeed: Float
  teamName: String
  combatClassAttack: String
  combatClassDefend: String
  unitRelationshipClass: String
  attackDesire: Float
  hasInventory: Boolean
  wakesNeutrals: Boolean
}

type PatchNoteLanguageType {
  id: String
  gameVersionId: Short
  languageId: Byte
  index: Byte
  abilityId: Short
  itemId: Short
  heroId: Short
  generalId: PatchNoteType
  text: String
}

enum PatchNoteType {
  HERO
  GENERAL
  GENERIC
  ITEM
  NPC
}

type ModifierType {
  id: Short
  name: String
  buffDuration: Int
  isRoot: Boolean
  isStun: Boolean
  isSilence: Boolean
  isInvisible: Boolean
  isShackle: Boolean
  isHex: Boolean
  isSleep: Boolean
  isCyclone: Boolean
  isTaunt: Boolean
  isDisarm: Boolean
  isBlind: Boolean
  isEthereal: Boolean
  isMovementSlow: Boolean
  isAttackSlow: Boolean
  isBreak: Boolean
  isArmorReduce: Boolean
  isAttackReduce: Boolean
  isMute: Boolean
  isDamageAmplified: Boolean
  isMovementDebuff: Boolean
  isKnockback: Boolean
  isWeaken: Boolean
  isItem: Boolean
  isBanished: Boolean
}

type LeaderboardQuery {
  """Returns the list of the current season leaderboard."""
  season(request: FilterSeasonLeaderboardRequestType): SteamAccountSeasonActiveLeaderboardType

  """
  Gets the players of Dota which have DotaPlus and have a high level hero.
  """
  dotaPlus(
    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short

    """
    Id representing how to order the dota plus leader board. Accepted values are Recent = 0 (Shows the most recent awards given) and Level = 1 (shows by the highest level first)
    """
    orderBy: FilterLeaderboardOrder

    """Only returns players of this level."""
    level: Byte

    """
    The amount of data to skip before collecting your query. This is useful for Paging.
    """
    skip: Int

    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int
  ): PlayerHeroDotaPlusLeaderboardRankResponseType

  """Show amount of active and expired DotaPlus users by Week"""
  dotaPlusWeek: [DotaPlusWeekType]

  """Gets the top player of DotaPlus order by Level and Time Achived."""
  dotaPlusTopLevels: [HeroDotaPlusLeaderboardRankTopType]

  """Gets the current leaderboard for Battle Pass levels."""
  battlePass(
    """The Event Id Assigned by Valve.  22 is TI8, 25 is TI9."""
    eventId: Byte
    countryCode: String
    levels: [Int]
  ): PlayerBattlePassResponseType

  """Gets the current leaderboard for Battle Pass levels."""
  battlePassGroupBy(
    """The Event Id Assigned by Valve.  22 is TI8, 25 is TI9."""
    groupBy: PlayerBattlePassGroupByEnum!

    """The Event Id Assigned by Valve.  22 is TI8, 25 is TI9."""
    eventId: Byte
    countryCode: String
  ): [PlayerBattlePassGroupByType]

  """Gets the current leaderboard for all coaches by level."""
  coaching(levels: [Int]): PlayerCoachingLeaderboardResponseType

  """Gets the current leaderboard for all guilds by points."""
  guild(request: FilterLeaderboardGuildRequestType): [GuildType]

  """
  Gets the current leaderboard for all players by a specific Hero, order by IMP.
  """
  hero(request: FilterLeaderboardHeroRequestType): [PlayerLeaderBoardByHeroType]
}

type SteamAccountSeasonActiveLeaderboardType {
  playerCount: Int
  players(
    """
    The amount of data to skip before collecting your query. This is useful for Paging.
    """
    skip: Long

    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Long
  ): [SteamAccountSeasonActiveLeaderboardRankType]
  countryData: [SteamAccountSeasonActiveLeaderboardCountryDataType]
  positionData: [SteamAccountSeasonActiveLeaderboardPositionDataType]
  teamData: [TeamType]
  teamIdData: [Int]
}

type SteamAccountSeasonActiveLeaderboardRankType {
  steamAccountId: Long
  steamAccount: SteamAccountType
  avgImp: Short
  divisionId: LeaderboardDivision
  lastUpdateDateTime: Long
  matchCount: Short
  position: MatchPlayerPositionType
  positionValue: Byte
  rank: Short
  rankShift: Short
  topHeroOne: Short
  topHeroTwo: Short
  topHeroThree: Short
  winRate: Byte
}

enum LeaderboardDivision {
  AMERICAS
  SE_ASIA
  EUROPE
  CHINA
}

type SteamAccountSeasonActiveLeaderboardCountryDataType {
  countryCode: String
  playerCount: Int
}

type SteamAccountSeasonActiveLeaderboardPositionDataType {
  position: MatchPlayerPositionType
  playerCount: Int
}

input FilterSeasonLeaderboardRequestType {
  query: String
  leaderBoardDivision: LeaderboardDivision
  heroId: Short
  position: MatchPlayerPositionType
  countryCode: String
  teamId: Int
}

type PlayerHeroDotaPlusLeaderboardRankResponseType {
  players: [HeroDotaPlusLeaderboardRankType]
}

enum FilterLeaderboardOrder {
  RECENT
  LEVEL
  FIRST
}

type DotaPlusWeekType {
  week: Int
  active: Int
  expired: Int
}

type HeroDotaPlusLeaderboardRankTopType {
  heroId: Short
  steamAccountId: Long
  level: Byte
  createdDateTime: Long
  steamAccount: SteamAccountType
}

type PlayerBattlePassResponseType {
  players(
    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int

    """
    The amount of data to skip before collecting your query. This is useful for Paging.
    """
    skip: Int
  ): [PlayerBattlePassType]
  levels: [Int!]!
}

type PlayerBattlePassType {
  steamAccountId: Long
  steamAccount: SteamAccountType
  level: Int!
}

type PlayerBattlePassGroupByType {
  id: String
  playerCount: Long
  sumLevels: Long
  playerCountAt1000: Long
}

enum PlayerBattlePassGroupByEnum {
  COUNTRY_CODE
  BRACKET
}

type PlayerCoachingLeaderboardResponseType {
  players(
    """
    The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
    """
    take: Int

    """
    The amount of data to skip before collecting your query. This is useful for Paging.
    """
    skip: Int
  ): [PlayerCoachingLeaderboardType]
  levels: [Int!]!
}

type PlayerCoachingLeaderboardType {
  steamAccountId: Long!
  steamAccount: SteamAccountType
  rating: Int!
  matchCount: Int!
  winCount: Int!
  firstMatchDateTime: Long
  lastMatchDateTime: Long
}

input FilterLeaderboardGuildRequestType {
  """What field to order the data by. Enum values."""
  orderBy: FilterLeaderboardGuildOrderBy

  """If the return should be ordered by Ascending or Desending order."""
  order: FilterOrder

  """What field to order the data by. Enum values."""
  region: Byte

  """If the guild is current set to 50 members."""
  isFull: Boolean

  """If anyone is able to join the guild."""
  isUnlocked: Boolean

  """The minimum amount of members a guild must have."""
  minMemberCount: Byte

  """The max amount of members a guild can have."""
  maxMemberCount: Byte

  """The amount of members a guild must have."""
  memberCount: Byte

  """The language required to join the guild."""
  language: Byte

  """The guild was created before this date time (in Unix TimeStamp)."""
  createdBeforeDateTime: Long

  """The guild was created after this date time (in Unix TimeStamp)."""
  createdAfterDateTime: Long

  """The rank required to join the guild."""
  minRequiredRank: Long

  """The rank required to join the guild."""
  maxRequiredRank: Long

  """
  The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
  """
  take: Int

  """
  The amount of data to skip before collecting your query. This is useful for Paging.
  """
  skip: Int
}

enum FilterLeaderboardGuildOrderBy {
  BATTLE_PASS_LEVELS
  MEMBER_COUNT
  POINTS
  ID
  PREVIOUS_WEEK_RANK
  RANK
}

input FilterLeaderboardHeroRequestType {
  """
  An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
  """
  heroIds: [Short]

  """
  An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
  """
  bracketIds: [RankBracket]

  """
  The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
  """
  take: Int!

  """
  The amount of data to skip before collecting your query. This is useful for Paging.
  """
  skip: Int
}

type LiveQuery {
  """
  Find a live match by match id. A live match is data where a match is on the Dota watch list and still active. All League games are also Live. id is a required input field.
  """
  match(
    """
    The id of the Dota match to include in this query, excluding all results that do not include this id.
    """
    id: Long!

    """
    The amount in seconds you wish to skip until you start getting MatchEvents or PlayerMatchEvents. When requesting reply data back, you may only want the updates from X second on. This will skip the first set of seconds and give everything after this time.
    """
    skipPlaybackDuration: Int
  ): MatchLiveType

  """
  Find all live matches. A live match is data where a match is on the Dota watch list and still active. All League games are also Live.
  """
  matches(request: MatchLiveRequestType): [MatchLiveType]
}

input MatchLiveRequestType {
  """
  The hero id to include in this query, excluding all results that do not include this hero.
  """
  heroId: Short

  """
  A league id to include in this query, excluding all results that do not have this league id.
  """
  leagueId: Int

  """
  Returns only matches that are currently still being updated by the backend.
  """
  isParsing: Boolean

  """
  Returns only matches that are no longer active and completed but not yet deleted.
  """
  isCompleted: Boolean

  """
  An array of league ids to include in this query, excluding all results that do not include one of these leagues.
  """
  leagueIds: [Int]

  """
  Only return Live Matches In Progress that are currently in these states.
  """
  gameStates: [MatchLiveGameState]

  """
  An array of tier ids to include in this query, excluding all results that do not include one of these tiers.
  """
  tiers: [LeagueTier]

  """
  Playback Data can contain a lot of information. This will only display the most recent event for each of the fields.
  """
  lastPlaybackEventOnly: Boolean

  """The order in which the data returned will be sorted by."""
  orderBy: MatchLiveRequestOrderBy

  """
  The amount to have returned in your query. The maximum of this is always dynamic. Limit : 
  """
  take: Int

  """
  The amount of data to skip before collecting your query. This is useful for Paging.
  """
  skip: Int
}

enum MatchLiveRequestOrderBy {
  GAME_TIME
  MATCH_ID
  SPECTATOR_COUNT
  AVERAGE_RANK
}

type VendorQuery {
  dotaNext: DotaNextQuery

  """Used by the Dota 2 Twitch Tracker for Dota Stats"""
  twitchTracker(
    """
    The steam account id to include in this query, excluding all results that do not have this steam account id.
    """
    steamAccountId: Long!
  ): TwitchTrackerPlayerType
}

type DotaNextQuery {
  """
  Used by Overwolf application DotaNext (previously called DotaPlus) to provide data to its users.
  """
  enemy(
    """
    An array of steam account ids to limit the query to only return matches with these steam account ids.
    """
    steamAccountIds: [Long]!

    """
    A steam account id found on your team to include in this query, excluding all results that do not include this steam account id found on your team.
    """
    matchSteamAccountId: Long!
  ): [DotaNextWithAllyType]

  """
  Used by Overwolf application DotaNext (previously called DotaPlus) to provide data to its users.
  """
  ally(
    """
    An array of steam account ids to limit the query to only return matches with these steam account ids.
    """
    steamAccountIds: [Long]!

    """
    A steam account id found on your team to include in this query, excluding all results that do not include this steam account id found on your team.
    """
    matchSteamAccountId: Long!
  ): [DotaNextWithAllyType]

  """
  Used by Overwolf application DotaNext (previously called DotaPlus) to provide data to its users.
  """
  playerHero(
    """
    An array of steam account ids to limit the query to only return matches with these steam account ids.
    """
    steamAccountIds: Long!

    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short

    """
    An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
    """
    gameModeIds: Byte!

    """
    An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types.
    """
    lobbyTypeIds: Byte!

    """
    An array of item ids to include in this query, excluding all results that do not include one of these item ids.
    """
    limitByItemIds: Int!

    """
    The start DateTime of the Dota match(es) to include in this query, represented in unix seconds.
    """
    startDateTime: Long!
  ): [[MatchPlayerItemPurchaseEventType]]
}

type DotaNextWithAllyType {
  steamAccountId: Long
  lifetimeMatchCount: Int
  lifetimeWinMatchCount: Int
}

type TwitchTrackerPlayerType {
  steamAccountId: Long
  activity: PlayerBehaviorActivity
  name: String
  avatar: String
  rank: Int
  leaderboardRank: Int
  proPlayerName: String
  matchCountLast100: Int!
  winCountLast100: Int!
  uniqueHeroLast100: Int!
  coreCountLast100: Int!
  topHeroLast100: [TwitchTrackerPlayerHeroType]
  matches: [TwitchTrackerPlayerMatchType]
}

type TwitchTrackerPlayerHeroType {
  heroId: Int!
  matchCount: Int!
  winCount: Int!
}

type TwitchTrackerPlayerMatchType {
  matchId: Long
  heroId: Int!
  lane: MatchLaneType
  role: MatchPlayerRoleType
  position: MatchPlayerPositionType
  killCount: Short
  deathCount: Short
  assistCount: Short
  endDateTime: Long
  isVictory: Boolean!
  award: Byte
}

type DotaMutation {
  yogurt: YogurtMutation
  user: DotaUserMutation
  admin: AdminMutation
}

type YogurtMutation {
  """
  Create a new match replay upload team. teamName, emailAddress, and teamId are required input fields.
  """
  createTeam(
    """
    The desired team name of the match replay upload team. Cannot be blank or whitespace.
    """
    matchReplayUploadTeamName: String!

    """
    The desired email address of the match replay upload team. Cannot be blank or whitespace.
    """
    emailAddress: String!

    """
    The desired dota team id of the match replay upload team. Must be a real team created in the dota client.
    """
    teamId: Int!
  ): MatchReplayUploadTeamType

  """
  Update a new match replay upload team. matchReplayUploadTeamId is a required input field.
  """
  updateTeam(
    """
    The desired team name of the match replay upload team. Cannot be blank or whitespace.
    """
    matchReplayUploadTeamId: Long!

    """
    The desired team name of the match replay upload team. Cannot be blank or whitespace.
    """
    matchReplayUploadTeamName: String

    """
    The desired dota team id of the match replay upload team. Must be a real team created in the dota client.
    """
    teamId: Int
  ): Boolean

  """
  Add a member to a match replay upload team. steamAccountId and matchReplayUploadTeamId are required input fields.
  """
  addTeamMember(
    """
    The steam account id to include in this query, excluding all results that do not have this steam account id.
    """
    steamAccountId: Long!

    """
    The id of the match replay upload team to include in this query, excluding all results that do not include this match replay upload team id.
    """
    matchReplayUploadTeamId: Long!
  ): Boolean

  """
  Update a member of a match replay upload team. memberCaptainJackIdentityId, matchReplayUploadTeamId, and isAdmin are required input fields.
  """
  updateTeamMember(
    """
    The CaptainJackIdentity id to include in this query, excluding all results that do not have this CaptainJackIdentity id.
    """
    captainJackIdentityId: ID!

    """
    The id of the match replay upload team to include in this query, excluding all results that do not include this match replay upload team id.
    """
    matchReplayUploadTeamId: Long!

    """
    Whether the match replay upload team member you wish to update is an admin of that team.
    """
    isAdmin: Boolean!
  ): Boolean

  """
  Set the default team of a match replay upload team member. memberCaptainJackIdentityId and matchReplayUploadTeamId are required input fields.
  """
  setTeamMemberDefaultTeam(
    """
    The CaptainJackIdentity id to include in this query, excluding all results that do not have this CaptainJackIdentity id.
    """
    captainJackIdentityId: ID!

    """
    The id of the match replay upload team to include in this query, excluding all results that do not include this match replay upload team id.
    """
    matchReplayUploadTeamId: Long!
  ): Boolean

  """
  Remove a member of a match replay upload team. memberCaptainJackIdentityId and matchReplayUploadTeamId are required input fields.
  """
  removeTeamMember(
    """
    The CaptainJackIdentity id to include in this query, excluding all results that do not have this CaptainJackIdentity id.
    """
    captainJackIdentityId: ID!

    """
    The id of the match replay upload team to include in this query, excluding all results that do not include this match replay upload team id.
    """
    matchReplayUploadTeamId: Long!
  ): Boolean

  """
  Update the data of a match replay upload. updateMatchReplayUploadObject is a required input field.
  """
  update(
    """
    This object contains all of the fields a user is allowed to update on a match replay upload. Null fields are not updated. Fields set to 0 are updated to null in the database.
    """
    updateMatchReplayUploadObject: UpdateMatchReplayUploadObjectType!
  ): Boolean

  """
  Validate the data of a match replay upload, adding the match replay upload to the queryable data set associated with the match replay upload team. matchReplayUploadTeamId and matchId are required input fields.
  """
  validate(
    """
    The id of the match replay upload team to include in this query, excluding all results that do not include this match replay upload team id.
    """
    matchReplayUploadTeamId: Long!

    """
    The id of the Dota match to include in this query, excluding all results that do not include this id.
    """
    matchId: Long!
  ): Boolean

  """
  Invalidate the data of a match replay upload, removing the match replay upload from the queryable data set associated with the match replay upload team. matchReplayUploadTeamId and matchId are required input fields.
  """
  invalidate(
    """
    The id of the match replay upload team to include in this query, excluding all results that do not include this match replay upload team id.
    """
    matchReplayUploadTeamId: Long!

    """
    The id of the Dota match to include in this query, excluding all results that do not include this id.
    """
    matchId: Long!
  ): Boolean

  """
  Delete the data of a match replay upload, removing the match replay upload from the queryable data set associated with the match replay upload team. matchReplayUploadTeamId and matchId are required input fields.
  """
  delete(
    """
    The id of the match replay upload team to include in this query, excluding all results that do not include this match replay upload team id.
    """
    matchReplayUploadTeamId: Long!

    """
    The id of the Dota match to include in this query, excluding all results that do not include this id.
    """
    matchId: Long!
  ): Boolean

  """
  Delete the data of a match replay upload, removing the match replay upload from the queryable data set associated with the match replay upload team. matchReplayUploadTeamId and matchId are required input fields.
  """
  linkSeriesId(
    """
    The id of the match replay upload team to include in this query, excluding all results that do not include this match replay upload team id.
    """
    matchReplayUploadTeamId: Long!

    """An array of Dota match ids to include in this query."""
    matchIds: [Long]!
  ): Boolean

  """
  Remove the series id for all of the input matches. matchReplayUploadTeamId and matchIds are required input fields.
  """
  removeSeriesId(
    """
    The id of the match replay upload team to include in this query, excluding all results that do not include this match replay upload team id.
    """
    matchReplayUploadTeamId: Long!

    """An array of Dota match ids to include in this query."""
    matchIds: [Long]!
  ): Boolean

  """
  Import a public match as a match replay upload to the match replay upload team's data set. matchReplayUploadTeamId and matchId are required input fields.
  """
  importMatch(
    """
    The id of the match replay upload team to include in this query, excluding all results that do not include this match replay upload team id.
    """
    matchReplayUploadTeamId: Long!

    """
    The id of the Dota match to include in this query, excluding all results that do not include this id.
    """
    matchId: Long!
  ): Boolean

  """
  If the Picks and Bans for a match are missing or invalid, this allows you to update them.
  """
  importPickBans(
    """
    The id of the match replay upload team to include in this query, excluding all results that do not include this match replay upload team id.
    """
    matchReplayUploadTeamId: Long!

    """
    The id of the Dota match to include in this query, excluding all results that do not include this id.
    """
    matchId: Long!
    pickBans: [ImportPickBanType]!
  ): Boolean
}

input UpdateMatchReplayUploadObjectType {
  matchReplayUploadTeamId: Int!
  matchId: Long
  leagueId: Int
  radiantTeamId: Int
  direTeamId: Int
  isActive: Boolean
  notes: String
  players: [UpdateMatchReplayMatchUploadPlayerObjectType]
}

input UpdateMatchReplayMatchUploadPlayerObjectType {
  steamAccountId: Long!
  position: MatchPlayerPositionType
}

input ImportPickBanType {
  playerSlot: Byte
  isPick: Boolean
  heroId: Short
  time: Byte
  isRadiant: Boolean
  order: Byte
  wasBannedSuccessfully: Boolean
}

type DotaUserMutation {
  """Marks the user's LastReadFeedTime to the current time."""
  readAllFeed: Boolean

  """Validates a user email address if the password id is correct."""
  validateEmail(
    """The password number that was sent via email."""
    code: Guid!
  ): Boolean

  """Update your user to unsubscribe from Stratz emails."""
  unsubscribeEmail(code: Guid!): UserHomepageType

  """Updates the logged in user information profile."""
  updateProfile(
    """
    The updated returned object from /user. Only updates ThemeType, LanguageId, Email and Feed/Email Settings.
    """
    request: CaptainJackIdentityProfileUpdateRequestType!
  ): Boolean

  """Update your user to (un)follow a specific SteamAccountId"""
  followPlayer(
    """The steam account of the person you wish to (un)follow."""
    steamAccountId: Long!
  ): Boolean

  """Update your user to (un)follow a specific SteamAccountId"""
  unfollowPlayer(
    """The steam account of the person you wish to (un)follow."""
    steamAccountId: Long!
  ): Boolean

  """Update your user to (un)follow a specific SteamAccountId"""
  updateFollowing(
    """The steam account of the person you wish to (un)follow."""
    followedSteamAccountId: Long!

    """
    The updated returned object from /user. Only updates ThemeType, LanguageId, Email and Feed/Email Settings.
    """
    request: UpdateFollowerRequestType!
  ): Boolean

  """
  Updates every user you are following.  This should be handled with care, as this overrides all your predefinded user specific settings with these settings.
  """
  updateAllFollowing(
    """
    The updated returned object from /user. Only updates ThemeType, LanguageId, Email and Feed/Email Settings.
    """
    request: UpdateFollowerRequestType!
  ): Boolean

  """
  Gets more in-depth information about the person you are following.  This is a user specific request, and you can only edit yourself.
  """
  updateFollowingFavorite(
    """The steam account of the person you wish to (un)follow."""
    followedSteamAccountId: Long!

    """Should the user become a favorite."""
    isFavorite: Boolean!
  ): Boolean

  """Update your user to (un)follow a specific LeagueId"""
  followLeague(
    """
    A league id to include in this query, excluding all results that do not have this league id.
    """
    leagueId: Int!
  ): Boolean
  unfollowLeague(
    """
    A league id to include in this query, excluding all results that do not have this league id.
    """
    leagueId: Int!
  ): Boolean
  applyStratzApiKey(
    """There are two type of API Tokens, Data Collector and MultiKey"""
    tokenType: StratzApiType!

    """
    The desired email address of the match replay upload team. Cannot be blank or whitespace.
    """
    emailAddress: String!

    """A users Discord full Identity name."""
    discordAddress: String!

    """A user website where the data can be seen."""
    websiteAddress: String!
    description: String!
  ): Boolean

  """
  If a user moves from annoymous to public, this will turn it on instantly for them.
  """
  checkPublicDotaAccount: Boolean
}

input CaptainJackIdentityProfileUpdateRequestType {
  email: String
  feedLevel: Byte
  emailLevel: Byte
  dailyEmail: Boolean
  weeklyEmail: Boolean
  monthlyEmail: Boolean
  proCircuitFeedLevel: Byte
  proCircuitEmailLevel: Byte
  themeType: Byte
  language: Language
  emailHour: Byte
  isStratzPublic: Boolean
}

input UpdateFollowerRequestType {
  feedLevel: Byte
  emailLevel: Byte
  dailyEmail: Boolean
  weeklyEmail: Boolean
  monthlyEmail: Boolean
  overrideAllUsers: Boolean!
}

type AdminMutation {
  mergeProSteamAccount(request: [MergeProSteamAccountRequestType]!): Boolean
  deleteProSteamAccount(request: DeleteProSteamAccountRequestType!): Boolean
}

input MergeProSteamAccountRequestType {
  steamAccountId: Long
  name: String
  realName: String
}

input DeleteProSteamAccountRequestType {
  steamAccountId: Long
  name: String
  realName: String
}

type DotaSubscription {
  matchCount: TotalMatchCountType
  playerCount: TotalPlayerCountType
  feedLive: LiveEventType
  matchLive(matchId: Long!): MatchLiveType
  matchLiveLeague(leagueId: Int!): MatchLiveType
}

type TotalMatchCountType {
  matchCount: Long
}

type TotalPlayerCountType {
  playerCount: Long
}

union LiveEventType = LiveEventPlayerRampageType | LiveEventPlayerWinStreakType | LiveEventPlayerHeroWinStreakType | LiveEventPlayerHeroKillsType | LiveEventPlayerHeroAssistsType | LiveEventPlayerHeroBuildingDamageType | LiveEventPlayerHeroHealingType | LiveEventPlayerHeroHeroDamageType | LiveEventPlayerHeroGoldPerMinuteType | LiveEventPlayerHeroExpPerMinuteType | LiveEventPlayerHeroHighImpType | LiveEventPlayerHeroDotaPlusLevelType | LiveEventPlayerRankUpType | LiveEventProPlayerLiveType | LiveEventPlayerHeroItemPurchaseType | LiveEventPlayerHeroDewardType | LiveEventMatchDireTideStompType | LiveEventPlayerDireTideCandyScoredType

type LiveEventPlayerRampageType {
  steamAccount: SteamAccountType
  match: MatchType
  heroId: Short
  rampageCount: Byte
}

type LiveEventPlayerWinStreakType {
  steamAccount: SteamAccountType
  match: MatchType
  winStreakCount: Byte
}

type LiveEventPlayerHeroWinStreakType {
  steamAccount: SteamAccountType
  match: MatchType
  heroId: Short
  winStreakCount: Byte
}

type LiveEventPlayerHeroKillsType {
  steamAccount: SteamAccountType
  match: MatchType
  heroId: Short
  killCount: Byte
}

type LiveEventPlayerHeroAssistsType {
  steamAccount: SteamAccountType
  match: MatchType
  heroId: Short
  assistCount: Byte
}

type LiveEventPlayerHeroBuildingDamageType {
  steamAccount: SteamAccountType
  match: MatchType
  heroId: Short
  buildingDamage: Int
}

type LiveEventPlayerHeroHealingType {
  steamAccount: SteamAccountType
  match: MatchType
  heroId: Short
  healingAmount: Int
}

type LiveEventPlayerHeroHeroDamageType {
  steamAccount: SteamAccountType
  match: MatchType
  heroId: Short
  heroDamage: Int
}

type LiveEventPlayerHeroGoldPerMinuteType {
  steamAccount: SteamAccountType
  match: MatchType
  heroId: Short
  goldPerMinute: Short
}

type LiveEventPlayerHeroExpPerMinuteType {
  steamAccount: SteamAccountType
  match: MatchType
  heroId: Short
  expPerMinute: Short
}

type LiveEventPlayerHeroHighImpType {
  steamAccount: SteamAccountType
  match: MatchType
  heroId: Short
  imp: Byte
}

type LiveEventPlayerHeroDotaPlusLevelType {
  steamAccount: SteamAccountType
  match: MatchType
  heroId: Short
  level: Byte
}

type LiveEventPlayerRankUpType {
  steamAccount: SteamAccountType
  match: MatchType
  rank: Byte
}

type LiveEventProPlayerLiveType {
  steamAccounts: [SteamAccountType]
  match: MatchLiveType
}

type LiveEventPlayerHeroItemPurchaseType {
  steamAccount: SteamAccountType
  match: MatchType
  heroId: Short
  itemId: Short
  itemCount: Byte
}

type LiveEventPlayerHeroDewardType {
  steamAccount: SteamAccountType
  match: MatchType
  heroId: Short
  dewardCount: Byte
}

type LiveEventMatchDireTideStompType {
  match: DireTideCustomGameMatchType
}

type LiveEventPlayerDireTideCandyScoredType {
  steamAccount: SteamAccountType
  match: DireTideCustomGameMatchType
  heroId: Short
  candyScored: Short
}
